---
title: "ASCII코드와 XOR 연산을 활용한 영리한 대소문자 변환"
date: 2025-05-30 17:26:13 +0900
categories: [IT, ETC]  
tags: [ps, ascii, bitwise, xor, encoding]    
toc: true
comment: false
published: true
image:
    path: "https://upload.wikimedia.org/wikipedia/commons/thumb/0/01/XOR_ANSI.svg/800px-XOR_ANSI.svg.png"
---

# ASCII 코드와 XOR 연산을 활용한 영리한 대소문자 변환 트릭

알고리즘 관련 영상을 보다가 굉장히 씽크빅인 아이디어를 발견해 기록해두려고 작성함

PS를 하다보면 문자열의 대소문자를 변환해야 하는 경우가 자주 있다

대부분의 언어에서는 `toUpperCase()`나 `toLowerCase()` 같은 편리한 함수를 제공하지만, 

ASCII 코드의 구조적 특성을 활용한 방법이 존재함

## 핵심 아이디어

**알파벳을 ASCII 코드로 변환한 후 `0x20`과 XOR 연산을 하면 대소문자를 변환할 수 있다!!**

## ASCII 코드 구조 분석

먼저 ASCII 코드에서 알파벳의 값들을 확인해보면

### 대문자 (A-Z)
- A: 65 (0x41)
- B: 66 (0x42)
- ...
- Z: 90 (0x5A)

### 소문자 (a-z)
- a: 97 (0x61)
- b: 98 (0x62)
- ...
- z: 122 (0x7A)

여기서 중요한 패턴을 발견할 수 있는데

**대문자와 소문자의 차이는 정확히 32 (0x20)라는 것**

## 이진수로 살펴보기

더 깊이 이해하기 위해 이진수로 표현해보면

```
대문자 'A': 0100 0001 (0x41 = 65)
소문자 'a': 0110 0001 (0x61 = 97)
           ↑
        6번째 비트만 다름!
```

```
대문자 'B': 0100 0010 (0x42 = 66)
소문자 'b': 0110 0010 (0x62 = 98)
           ↑
        6번째 비트만 다름!
```

모든 알파벳에서 대문자와 소문자는 **6번째 비트(32의 자리)만 다르다**.

## XOR 연산

`0x20`은 이진수로 `0010 0000`입니다. 이는 6번째 비트만 1이고 나머지는 모두 0인 값임

XOR 연산의 특성상:
- `0 XOR 1 = 1` (비트 설정)
- `1 XOR 1 = 0` (비트 해제)

따라서:

### 대문자 → 소문자

```
'A' (0x41): 0100 0001
XOR 0x20:   0010 0000
결과:       0110 0001 = 0x61 ('a')
```

### 소문자 → 대문자
```
'a' (0x61): 0110 0001
XOR 0x20:   0010 0000
결과:       0100 0001 = 0x41 ('A')
```

처럼 쉽게 변환할 수 있다

## 실제 코드 예시

### C/C++

```c
char toggleCase(char c) {
    return c ^ 0x20;
}

// 사용 예시
char upper = 'A';
char lower = toggleCase(upper); // 'a'
char back = toggleCase(lower);  // 'A'
```

### Python
```python
def toggle_case(c):
    return chr(ord(c) ^ 0x20)

# 사용 예시
upper = 'A'
lower = toggle_case(upper)  # 'a'
back = toggle_case(lower)   # 'A'
```

## 주의사항

이 방법은 유용해보이지만 몇 가지 주의할 점이 있음

1. **알파벳 문자에서만 작동**: 숫자나 특수문자에 적용하면 예상치 못한 결과가 나올 수 있다

2. **ASCII 범위에서만 유효**: 유니코드 문자나 다른 인코딩에서는 작동하지 않음

3. **안전성 검사 필요**: 알파벳이 아닌 값이 들어오면 난리남

### 안전한 구현 예시 (C)

```c
char safeToggleCase(char c) {
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
        return c ^ 0x20;
    }
    return c; // 알파벳이 아니면 그대로 반환
}
```

## 성능상의 이점

이 방법의 장점은:

- **빠른 실행속도**: 단순한 비트 연산 하나로 처리
- **메모리 효율적**: 추가 메모리 할당 불필요
- **조건문 불필요**: if-else 없이 한 번에 처리 가능

## 마무리

ASCII 코드의 구조적 특성을 이해하고 XOR 연산을 활용한 이 방법은 효율적이지만,

실제 개발에서는 언어에서 제공하는 표준 함수를 사용하는것이 더 안전하고 가독성이 좋을것이라고 생각함

그래도 이러한 저수준의 동작 원리를 이해하는 것은 개발자로서 큰 도움이 된다고 생각해서 정리해봄