---
title: "9242 폭탄 해체(C++)"
date: 2024-01-12 20:26:00 +0900
categories: [Algorithm, Problem Solving]  # 최대 2개 가능
tags: [impl, string, parsing]     # 태그는 항상 소문자로 작성할 것
toc: true
comment: false
published: true
---

[폭탄 해체](https://www.acmicpc.net/problem/9242)

폭탄에 출력되는 글자를 보고 문자열로 변환하는 문제

임베디드 도트 매트릭스의 추억이 생각난다 

![186bd1c3e7c5258ab](https://github.com/jinhg0214/jinhg0214.github.io/assets/70011316/773b9877-d3bb-4c7e-9290-4876be4afcdf)

# 1. 문제
---
### 간단 설명

![image](https://github.com/jinhg0214/jinhg0214.github.io/assets/70011316/f4e47af8-c46d-4e17-8393-54cc3527cc1e)

입력으로 폭탄의 코드가 주어지는데

![image](https://github.com/jinhg0214/jinhg0214.github.io/assets/70011316/62f2160b-5783-475b-9eab-8c55bd786927)

다음과 같이 보드에 글자가 도트 매트릭스로 출력이 된다

각 글자는 5*3 크기이고, 전체 코드는 최소 2글자부터 최대 8글자까지 가능하다


# 2. 문제 분석
---
### 주의점
- 폭탄 코드의 최대 길이는 8글자
- 각 코드 사이에는 빈칸이 하나씩 있다
- 올바르지 않은 숫자가 주어질 수 있다(?) 문자가 깨져서 나오는게 가능하다는건지 모르겠음
- 인덱스 접근에 주의한다

### 필요변수
- 0~9 숫자의 모양을 미리 정의해둔 `string num[5][10]`
- 입력값들을 저장할 `string input[5]`
- 폭탄 코드가 몇글자인지 저장할 `int num_size`
- 최종 폭탄 코드를 숫자로 저장한 `int result` 

### 알고리즘
```
1. 첫줄을 읽고, 폭탄 코드의 글자수가 몇개인지 파악한다
    - 각 글자 사이에는 공백이 있으므로, 마지막에 공백을 추가해서 4의 배수로 맞춰 나눈다
    - 이후 나머지 입력들도 input 문자열 배열에 저장한다
2. 각 글자가 어떤 글자인지 체크한다
    - 미리 정의한 0-9 중에 어떤 수와 일치하는지 확인한다
    - 숫자가 일치한다면 이를 result에 마지막 자리에 추가한다
3. 결과 숫자를 6으로 나누어 떨어지면 BEER!!를, 아니라면 BOOM!!을 출력 후 종료
```

```
0123456789012345678901234567890
*** *** *** *** *** *** *** *** 
*** *** *** *** *** *** *** *** 
*** *** *** *** *** *** *** *** 
*** *** *** *** *** *** *** *** 
*** *** *** *** *** *** *** *** 

첫번째 글자의 인덱스 0-2 
두번째 글자의 인덱스 4-6
세번째 글자의 인덱스 8-10
네번째 글자의 인덱스 12-14
다섯번째 글자의 인덱스 16-18
여섯번째 글자의 인덱스 20-22
일곱번째 글자의 인덱스 24-26
여덟번째 글자의 인덱스 28-30
```

num_size 와 index i 를 이용해 일반식을 구하면

0, 4, 8, 12, 16, 20, 24, 28번째, 4의 배수마다 글자가 시작하는것을 알 수 있다

`input[k].substr(i*4, 3)`를 통해 4의 배수마다 3글자씩 읽는다

# 3. 소스코드
---

```cpp
#include <iostream>
#include <string>

using namespace std;

string num[10][5] = {
	// 0
	"***",
	"* *",
	"* *",
	"* *",
	"***",
	// 1
	"  *",
	"  *",
	"  *",
	"  *",
	"  *",
	// 2
	"***",
	"  *",
	"***",
	"*  ",
	"***",
	// 3
	"***",
	"  *",
	"***",
	"  *",
	"***",
	// 4
	"* *",
	"* *",
	"***",
	"  *",
	"  *",
	// 5
	"***",
	"*  ",
	"***",
	"  *",
	"***",
	// 6
	"***",
	"*  ",
	"***",
	"* *",
	"***",
	// 7
	"***",
	"  *",
	"  *",
	"  *",
	"  *",
	// 8
	"***",
	"* *",
	"***",
	"* *",
	"***",
	// 9
	"***",
	"* *",
	"***",
	"  *",
	"***",
};

int main() {
	freopen_s(new FILE*, "input.txt", "r", stdin);

	string input[5];
	int num_size; // 몇글자인지 
	int result = 0;  

	// 1. 첫줄을 읽고 문자가 몇개인지 파악해본다
	getline(cin, input[0]);
	input[0] += " "; // 마지막 글자에 공백을 추가해 글자수를 4칸 간격으로 맞춘다
	
	num_size = input[0].size() / 4;

	// 나머지 4줄도 입력받기
	for (int i = 1; i < 5; i++) {
		getline(cin, input[i]);
		input[i] += " "; // 마찬가지로 공백 추가 
	}

	// 2. 각 글자가 어떤 글자인지 체크
	
	for (int i = 0; i < num_size; i++) {
		for (int j = 0; j < 10; j++) { // 0부터 9 까지 어떤 수랑 같은지 체크한다
			bool flag = true;
			for (int k = 0; k < 5; k++) {
				/*cout << num[j][k] << endl;
				cout << input[k].substr(i*4, 3) << endl;*/
				if (num[j][k] != input[k].substr(i*4, 3)) {
					flag = false;
					break;
				}
			}
			if (flag == true) {
				result = result * 10 + j;
			}
		}
	}

	if (result % 6 == 0) {
		cout << "BEER!!" << endl;
	}
	else {
		cout << "BOOM!!" << endl;
	}
	

	return 0;
}
```