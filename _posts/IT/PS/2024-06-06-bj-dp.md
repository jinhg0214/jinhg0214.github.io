---
title: "백준 DP 문제들 3"
date: 2024-06-06 02:00:00 +0900
# last_modified_at: 
categories: [Algorithm, Problem Solving] 
tags: [cpp, dp, twodimensional, bruteforce] 
toc: true
comment: false
published: true
image:
    path: "https://media.geeksforgeeks.org/wp-content/uploads/20240319104901/dynamic-programming.webp"
    alt: "https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png"
---

[알고리즘 기초 문제](https://jinhg0214.github.io/posts/problems/) 중 DP 기본 문제(400)

[이친수](https://www.acmicpc.net/problem/2193)

[가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

[가장 긴 감소하는 부분 수열](https://www.acmicpc.net/problem/11722)

[연속합](https://www.acmicpc.net/problem/1912

비슷한 문제들인것 같아 같이 묶어서 포스팅함


## 1. 이친수

### 간단 설명
0과 1로 이루어진 수는 이진수인데, 이친수는 다음과 같은 성질을 갖는다

1. 0으로 시작하지 않고
2. 1이 두번 연속으로 나타나지 않는 수 -> 11을 부분 문자열로 갖지 않음

N이 주어졌을 떄, N자리 이친수의 개수를 구하는 프로그램 

### 예시

```
1자리 -> 1 : 1개
2자리 -> 10, 11(X) : 1개
3자리 -> 100, 101, 110(X), 111(X) : 2개
4자리 -> 1000 1001 1010 1011(X) 1100(X) 1101(X) 1110(X) 1111(X) : 3개 
```

### 점화식

`dp[i][j]`를 i자리수의 글자 중 j로 끝나는 수의 개수라고 하면

i는 1~90, j는 0또는 1 2가지밖에 없다

dp[i][j] 의 값은 2^N 의 값이므로, int형보다 큰 long long int를 사용함

```
dp[1][0] = 0
dp[1][1] = 1
dp[2][0] = 1
dp[2][1] = 0 (11은 불가능)
dp[3][0] = 1
dp[3][1] = 1 
dp[4][0] = 2
dp[4][1] = 1
...
```
이런식으로 증가하게 된다

자세히 살펴보면, 0으로 끝나는 경우는 0또는 1이 올수 있지만

1로 끝나는 경우는 이후 1이 와버리면 11 부분문자열이 생성되기 때문에 0만 올 수 있다

이를 정리하면

```
dp[i][0] = dp[i-1][0] + dp[i-1][1]
dp[i][1] = dp[i-1][0] 
```
으로 정리할 수 있다

### 소스코드

```cpp
#include <iostream>

using namespace std;

int N;
long long int dp[91][2]; 

int main() {
	cin >> N;

	dp[1][1] = 1;
	dp[2][0] = 1;
	
	for (int i = 3; i <= N; i++) {
		dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
		dp[i][1] = dp[i - 1][0];
	}

	cout << dp[N][0] + dp[N][1];

	return 0;
}
```

## 가장 긴 증가하는 부분 수열

### 간단 설명
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램짜기

### 예시

A = {10, 20, 10, 30, 20, 50} 인 경우에 

가장 긴 증가하는 부분 수열은 A = {*10*, *20*, 10, *30*, 20, *50*} 이고, 길이는 4

### 점화식


dp[i]를 가장 긴 증가하는 부분수열의 길이라고 하면

```
Ai	10 20 10 30 20 50
dp  1 

Ai	10 20 10 30 20 50
dp  1  2

Ai	10 20 10 30 20 50 
dp  1  2  1 

Ai	10 20 10 30 20 50
dp  1  2  1  3

Ai	10 20 10 30 20 50
dp  1  2  1  3  2

Ai	10 20 10 30 20 50
dp  1  2  1  3  2  4

```
이런식으로 증가하게 된다

현재 보고있는 수 A_i가, 이전의 수 A_(i-1)보다 크다면, 

가장 긴 증가하는 부분 수열을 찾고, 그 크기를 1 늘려준다 (자기도 그 수열에 포함하는것)

```
if a_i > a_(i-1) : 
	dp[i] = dp[0] ~ dp[i-1] 값 중, 가장 큰 값에 + 1을 해준 값  
```

### 소스코드

```cpp
#include <iostream>
#include <cmath>

using namespace std;

int N;
int arr[1001];
long int dp[1001];

int main() {
	// freopen_s(new FILE*, "input.txt", "r", stdin);
	cin >> N;

	for (int i = 0; i < N; i++) {
		cin >> arr[i];
		dp[i] = 1;
	}

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < i; j++) {
			if (arr[i] <= arr[j]) continue;

			dp[i] = max(dp[i], dp[j] + 1);
		}
	}

	int res = 0;
	for (int i = 0; i < N; i++) {
		if (res < dp[i]) {
			res = dp[i];
		}
	}

	cout << res;

	return 0;
}
```


## 3. 가장 긴 감소하는 부분 수열

### 간단 설명
[가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) 문제와는 반대로

가장 긴 감소하는 부분수열을 찾는 문제

### 예시

수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 

가장 긴 감소하는 부분 수열은 A = {10, *30*, 10, *20*, 20, *10*}  이고, 길이는 3

### 점화식

마찬가지로 dp[i]를 가장 긴 감소하는 부분 수열의 길이로 놓으면

```
Ai 10 30 10 20 20 10
dp 1

Ai 10 30 10 20 20 10
dp 1  1

Ai 10 30 10 20 20 10
dp 1  1  2

Ai 10 30 10 20 20 10
dp 1  1  2  2

Ai 10 30 10 20 20 10
dp 1  1  2  2  2

Ai 10 30 10 20 20 10
dp 1  1  2  2  2  3
```
이런식으로 긴 부분 수열의 길이를 찾을 수 있음

```
if a_i < a_(i-1) : 
	dp[i] : dp[0]~dp[i-1] 에서 최대값 +1
```
로 점화식을 뽑을 수 있다

### 소스코드

```cpp
#include <iostream>

using namespace std;

int N;
int arr[1001];
int dp[1001];

int main() {
	// freopen_s(new FILE*, "input.txt", "r", stdin);
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> arr[i];
		dp[i] = 1;
	}


	for (int i = 0; i < N; i++) {
		for (int j = 0; j < i; j++) {
			if (arr[i] >= arr[j]) continue;

			dp[i] = max(dp[i], dp[j] + 1);
		}
	}

	int res = 0;
	for (int i = 0; i < N; i++) {
		if (res < dp[i]) {
			res = dp[i];
		}
	}

	cout << res;

	return 0;
}
```

## 4. 연속합

### 간단 설명
n개의 정수로 이루어진 임의의 수열

이 중 연속된 몇개의 수를 선택해서 구할 수 있는 합 중, 가장 큰 합을 구하는 문제

### 예시

10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이 주어진 경우

가장 큰 연속된 수의 합은 12, 21을 선택한 33이다

### 주의사항

- `2 -1 99`인 경우 처럼 음수를 선택해도 큰 수 가 될수 있음

- `-1, -2, -3, -4, -5` 처럼 원소의 값이 -1000까지 가능함


### 점화식

i까지 더한 수 중, 가장 큰 연속된 수의 합을 dp[i] 로 놓으면

연속된 수의 합이므로, '이전까지 더해온 수의 합에 자기 자신을 더한 경우'와 '자기 자신만 선택한 경우'를 비교한다

```

ai 10, -4, 3, 1, 5, 6, -35, 12, 21, -1
dp 10, 

첫번째는 자기자신을 더한 경우만 존재

ai 10, -4, 3, 1, 5, 6, -35, 12, 21, -1
dp 10, 6

두번째는 이전까지 더해온 수(dp[0])와 자기자신(a[1])을 더한 값 6과
자기 자신만을 선택한 경우(a[1])의 값 -4를 비교한 후, 큰 값을 기록한다

ai 10, -4, 3, 1, 5, 6, -35, 12, 21, -1
dp 10, 6,  9

세번쨰도 이전까지 더해온 수와 자기자신을 더한 값 dp[1] + a[2] = 9와
자기 자신만 선택한 경우 a[2] = 3을 비교한다.

```
이런식으로 점화식을 뽑으면

`dp[i] = max(dp[i-1] + a[i], a[i])` 

로 알 수 있다.

### 소스코드

```cpp

#include <iostream>
#include <vector>

using namespace std;

int dp[100001];

int main() {
	// freopen_s(new FILE*, "input.txt", "r", stdin);
	int N;
	cin >> N;
	vector<int> v(N);

	for (int i = 0; i < N; i++) {
		cin >> v[i];
		dp[i] = -21e8; // dp 배열의 값들을 -21억으로 초기화함
	}
	
	dp[0] = v[0]; // 첫번째 원소를 골라서 기록

	for (int i = 1; i < N; i++) {
		dp[i] = max(dp[i - 1] + v[i], v[i]);
	}

	int max = -21e8;
	for (int i = 0; i < N; i++) {
		if (max < dp[i]) {
			max = dp[i];
		}
	}
	cout << max;

	return 0;
}
```

문제 보고 점화식을 척척 잘 뽑는 사람들 보면 신기하다

역시 많이 풀어보는 경험이 중요한걸까..