---
title: "1174 줄어드는 수"
date: 2024-01-08 +0900
categories: [Algorithm, Problem Solving]  # 최대 2개 가능
tags: [bruteforce, dfs]     # 태그는 항상 소문자로 작성할 것
toc: true
comment: false
published: true
---

[줄어드는 수](https://www.acmicpc.net/problem/1174)

N번째 있는 '줄어드는 수'를 구하는 문제

![image](https://github.com/jinhg0214/jinhg0214.github.io/assets/70011316/dfea294d-c802-4948-be07-293490caf8f5)


# 1. 문제
---
### 간단 설명

N번째 있는 줄어드는 수를 구하는 문제

'줄어드는 수'란, 321, 987처럼 큰 자리수부터 작은자리수로 갈 때, 수도 줄어드는 수를 말한다

첫번째 줄어드는 수(N=1)는 0, 두번쨰 줄어드는 수(N=2)는 1, ...

이런식으로 갈때, N이 주어질 때, 그에 해당하는 수를 출력하는 문제

# 2. 문제 분석
---
### 주의점
- N이 1,000,000 이하의 자연수이다. 

   이는 백만번째 줄어는 수가 뭔지 물어보는거지, 해당 수가 백만보다 작다는 말이 아님

- 가장 큰 줄어드는 수는 10진수의 한계로 인해 '9876543210' 이다.

- 이를 이용해 이 수가 몇번째 등장하는지를 구하면 그 이후로는 구할 필요가 없다

- bruteforce로 시도할 시, 시간 복잡도 확인 필요

n이 1022일때, 줄어드는 수가 `9876543210`이라면

i=0부터 `9876543210` 까지 반복문 돌려서 i가 줄어드는 수인지 확인하면 되는거 아닌가 싶겠지만

이미 약 10억번 가까이 루프를 돌기 떄문에 숫자를 확인하는 함수를 잘 짠다고 해도 시간초과가 남

### 알고리즘
- 대신 DFS를 이용해서 해결한다

![image](https://github.com/jinhg0214/jinhg0214.github.io/assets/70011316/67ab5382-7beb-40d4-95fe-d7e8acf26e59)

`dfs(level, sum)`을 이용해, 

각 숫자를 sum에 추가할지 말지 결정한다.

level = 0 : 9를 선택하고 숫자에 추가하기 혹은 패스
level = 1 : 8을 선택하고 숫자에 추가하기 혹은 패스
... 
level = 9 : 0를 선택하고 숫자에 추가하기 혹은 패스

이런식으로 진행하여 생성한 숫자들을 모두 결과 벡터에 넣는다

이후 이 벡터를 정렬하고, 중복을 제거한 뒤, n번째 원소를 출력하면 끝

- n의 최대값은 1022이므로, 1023 이상은 -1을 출력한다

### 필요변수

`int n` (n<= 1,000,000)

결과를 저장할 벡터 `result` 결과는 int형을 초과할 수 있기 때문에 long long int 사용

`dfs(level, num)` 함수. num 또한 long long int 사용

`sort`, `unique`를 이용하기 위한 `algorithm 헤더`

# 3. 소스코드
---
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int arr[10] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
vector<long long int> result;

void dfs(int level, long long int num) {
	result.push_back(num);
	if (level >= 10) return;

	dfs(level + 1, num * 10 + arr[level]);
	dfs(level + 1, num);
}

int main() {
	int n;
	cin >> n;

	if (n > 1023) {
		cout << -1;
		return 0;
	}

	dfs(0, 0);

	sort(result.begin(), result.end());
	result.erase(unique(result.begin(), result.end()), result.end());

	cout << result[n-1];

	return 0;
}
```