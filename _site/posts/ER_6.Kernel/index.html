<!doctype html><html lang="ko-KR" data-mode="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="RTOS 팩토리 - Kernel 이야기" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Embedded Recipes" /><meta property="og:description" content="Embedded Recipes" /><link rel="canonical" href="https://jinhg0214.github.io/posts/ER_6.Kernel/" /><meta property="og:url" content="https://jinhg0214.github.io/posts/ER_6.Kernel/" /><meta property="og:site_name" content="Dukgukim" /><meta property="og:image" content="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-06-11T12:00:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" /><meta property="twitter:title" content="RTOS 팩토리 - Kernel 이야기" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-07T21:35:57+09:00","datePublished":"2024-06-11T12:00:00+09:00","description":"Embedded Recipes","headline":"RTOS 팩토리 - Kernel 이야기","image":{"alt":null,"url":"https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jinhg0214.github.io/posts/ER_6.Kernel/"},"url":"https://jinhg0214.github.io/posts/ER_6.Kernel/"}</script><title>6. RTOS 팩토리 - Kernel 이야기 | Dukgukim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dukgukim"><meta name="application-name" content="Dukgukim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/ko.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Dukgukim</a><p class="site-subtitle fst-italic mb-0">이것저것 기록 블로그</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>정보</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/jinhg0214" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">홈</a> </span> <span>6. RTOS 팩토리 - Kernel 이야기</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 포스트</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">취소</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>6. RTOS 팩토리 - Kernel 이야기</h1><div class="post-meta text-muted"> <span> 게시 <time data-ts="1718074800" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2024/06/11 </time> </span> <span> 업데이트 <time data-ts="1738931757" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2025/02/07 </time> </span><div class="mt-3 mb-3"> <a href="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" class="popup img-link preview-img shimmer"><img src="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/jinhg0214">Dukgukim</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5108 단어" > <em>28 분</em>읽는 시간</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">6. RTOS 팩토리 - Kernel 이야기</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">바로가기</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">6. RTOS 팩토리 - Kernel 이야기</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p><a href="https://jinhg0214.github.io/posts/Embedded_Recipes/">Embedded Recipes</a></p><h2 id="목차"><span class="me-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><a href="https://recipes.tistory.com/355">ⓐ RTOS와 Kernel</a><li><a href="https://recipes.tistory.com/356">ⓑ Embedded Software는 무한 Loop</a><li><a href="https://recipes.tistory.com/357">ⓒ Task 구조와 Signal</a><li><a href="https://recipes.tistory.com/358">ⓓ Task 상태, Task는 Service단위</a><li><a href="https://recipes.tistory.com/359">ⓔ Preemptive (선점형) Multitasking 이란 도대체</a><li><a href="https://recipes.tistory.com/360">ⓕ Context Swtiching과 TCB - Task의 상태변화</a><li><a href="https://recipes.tistory.com/361">ⓖ TCB - Task Control Block</a><li><a href="https://recipes.tistory.com/362">ⓗ Scheduler의 구현</a><li><a href="https://recipes.tistory.com/363">ⓘ ISR은 어떻게 구현해 - 선점형과 비선점형</a><li><a href="https://recipes.tistory.com/364">ⓙ 선점형 Kernel에서 wait, send, clr signal의 구현과 IRQ Handler</a> <li><a href="https://recipes.tistory.com/365">ⓚ Clock tick ISR - Timer Service</a><li><a href="https://recipes.tistory.com/366">ⓛ ATOMIC - Critical Section Mutex Semaphore</a><li><a href="https://recipes.tistory.com/367">ⓜ Interrupt VS. Polling</a><li><a href="https://recipes.tistory.com/368">ⓝ Queue와 Inter Task Communication</a><li><a href="https://recipes.tistory.com/369">ⓞ DPC나 APC, 그리고 Bottom Half</a>  <li><a href="https://recipes.tistory.com/370">ⓟ Watch dog task</a><li><a href="https://recipes.tistory.com/371">ⓠ Bootup 중 Kernel로의 진입 - main() 함수 -</a><li><a href="https://recipes.tistory.com/372">ⓡ Kernel을 Porting 한다는 것</a></ul><h2 id="ⓐ-rtos와-kernel"><span class="me-2">ⓐ RTOS와 Kernel</span><a href="#ⓐ-rtos와-kernel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>OS가 없던 시절에는 사용자가 모든 기능을 작성했음<li>편의를 위해 소프트웨어를 하드웨어에 자동으로 적재하고, 실행해주는 모니터 환경을 만듬<li>모든 소프트웨어는 I/O를 가지고 있다는 공통점이 있음<ul><li>이 부분을 모니터링 환경에 아예 집어넣고 사용하기 시작함</ul><li>태초의 OS는 DOS 형태로서 실행만 해주면 자동으로 메모리에 올려서 실행 가능하게 만들어주고, 특별한 처리과정 없이 I/O를 사용할 수 있도록 함<li>RTOS<ul><li>임베디드 시스템에서 사용되는 OS<li>특정 목적을 위한 작은 시스템이다보니, Real Time이라는 단어가 붙어 RTOS가 됨<li>멀티태스킹과 인터럽트 처리 기능을 가지고 있는 작은 OS<li>RTOS에서 중요한 부분만 따로 떼어 Kernel이라 부르는 부분들이 생겨남</ul><li>Kernel<ul><li>Switching, Scheduling, Memory Management, ISR Management 등<li>Kernel이 활성화 되려면, 커널의 API가 불리던 인터럽트가 불리던 호출되어야함<li>Kernel의 정의와 Micro Kernel, Monolithic Kernel간의 정리 필요<li>핵심 기능을 하는 부분은 “OS의 커널”이라 부름<ul><li>Micro Kernel은 진짜 중요한 부분만 커널이라 부름<li>Monolithic Kernel은 다른 큰 부분을 포함해서 엮어 커널이라 부름</ul></ul><li>리눅스는 Monolithic Kernel 형태이므로, 리눅스 자체 = 커널 = OS<li>L4같은 운영체제는 Micro Kernel 형태이므로, Core만 krenel이고, 나머지 Services들은 Server라는 Process 형태로 존재함</ul><h2 id="ⓑ-embedded-software는-무한-loop"><span class="me-2">ⓑ Embedded Software는 무한 Loop</span><a href="#ⓑ-embedded-software는-무한-loop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>대부분의 임베디드 소프트웨어는 특정한 목적을 가진 시스템이 대부분<li>한 개의 소프트웨어가 동작하는게 정석<li>대부분 무한 Loop를 이용해 구현함 ```c void <strong>main</strong> ()<br /> {</ul><p>   Lamp_init();</p><p>   while (1)<br />    {<br />       Lamp_on();<br />       wait (100); /* wait 100uS <em>/<br />       Lamp_off();            wait (100); /</em> wait 100uS */<br />    }<br /> }</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre>
## ⓒ Task 구조와 Signal
---
- 무한 루프에 기능을 추가하려면 함수를 추가해야함
- RTOS는 Hard / Soft 타입으로 구분됨
	- Hard 타입은 정해진 시간 안에 응답을 주어야하는 소프트웨어. 위성, 미사일등에 사용
	- Soft 타입은 응답을 주기만 하면됨
	- 현재에는 컴퓨팅 파워가 좋아져서 크게 구분하지 않음
- RTOS에 Scheduler 기능을 통해 무한 루프 내의 기능들을 관리하기 시작함
	- Signal을 통해 서로 통신. 함수들끼리 서로 작업상황을 알 수 있음
```c
void **main** ()  
{  
     Make_Ready (Lamp_task());         
     wait (DONE);        /* Lamp task는 init을 하고 DONE을 주고 WORK을 기다리겠지? */  
     Make_Ready (Motor_task());       
     wait (DONE);        /* Motor task는 init을 하고 DONE을 주고 WORK을 기다리겠지? */  
     send (LAMP, WORK)  /* Lamp task야 깜빡여 보렴 */  
    
     return;   /* Good bye forever */  
}  
   
void **Lamp_task** ()  
{  
   
     Lamp_init();  
                                    /* 우선은 초기화는 무조건 하네 */  
     send (main, DONE);   /* wait을 만나면 main으로 돌아가~ */  
  
     while (1)  
     {  
          wait (WORK);        /* 여기서 WORK이라는 signal을 일단 무작정 기다리죠 */  
                                    /* while(1)이니까 한번 깜빡이면 항상 여기서 signal을 기다리죠 */  
                                    /* Signal을 받기만 하면, 일을 시작 할테야 */  
           clear (WORK);       /* WORK을 받았으니 다음번에도 WORK을 받을 수 있도록 초기화 해주자 */  
            Lamp_on();  
            time_wait (100); /* wait 100uS */  
   
            Lamp_off();  
            time_wait (100); /* wait 100uS */  
   
          send (MOTOR, WORK);  /* Motor task야 Motor를 돌려봐 */  
      }  
}  
   
void **Motor_task** ()  
{  
   
    Motor_init();  
                                    /* 우선은 초기화는 무조건 하네 */  
    send (main, DONE);   /* wait을 만나면 main으로 돌아가~ */  
  
     while (1)  
     {  
          wait (WORK);        /* 여기서 WORK이라는 signal을 일단 무작정 기다린다 */  
                                    /* while(1)이니까 한번 깜빡이면 항상 여기서 signal을 기다린다 */  
                                    /* Signal을 받기만 하면, 일을 시작 할테야 */■  
          clear (WORK);       /* WORK을 받았으니, 다음번에도 WORK을 받을 수 있도록 초기화 해 주자 */  
            Motor_on();  
            time_wait (100); /* wait 100uS */  
   
            Motor_off();  
            time_wait (100); /* wait 100uS */  
   
            send (LAMP, WORK);   /* Lamp task야 Lamp를 깜빡여봐 */  
      }  
}
</pre></table></code></div></div><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdrP9tp%2Fbtsh9DgCoah%2F4Ccp1MdwyCWXuKJqsFvb0k%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdrP9tp%2Fbtsh9DgCoah%2F4Ccp1MdwyCWXuKJqsFvb0k%2Fimg.jpg" alt="task" loading="lazy"></a></p><ul><li>Task : 스케줄링의 기본 단위. 시스템은 태스크 단위로 일을 나눔<li>Task ∋ Process, Thread<ul><li>즉, Task는 프로세스 혹은 Thread로 구현됨<li>프로세스와 쓰레드는 별도로 다룰 예정</ul></ul><h2 id="ⓓ-task-상태-task는-service단위"><span class="me-2">ⓓ Task 상태, Task는 Service단위</span><a href="#ⓓ-task-상태-task는-service단위" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDiHP0%2FbtsiaAX0C5p%2FDXrGQG10pWdOsbkzPKCtLk%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDiHP0%2FbtsiaAX0C5p%2FDXrGQG10pWdOsbkzPKCtLk%2Fimg.jpg" alt="diagram" loading="lazy"></a></p><ul><li>Task의 State Transition Diagram<ul><li>커널 레벨에서 관리함. TCB에 포함<ol><li>Init State : 초기화. 태스크 관리 테이블에 등록됨<li>Wait State : 대기 상태. 어떤 조건을 만족하지 못해 실행을 대기함<li>Ready State : 실행될 준비가 된 상태. 모든 조건을 만족하여 대기중<li>Running : 실행 단계</ol></ul><li>Interrupt<ul><li>Hardware로 부터 진짜 전기 신호가 비정기적으로(Asynchronous) 전달됨</ul></ul><h2 id="ⓔ-preemptive-선점형-multitasking-이란-도대체"><span class="me-2">ⓔ Preemptive (선점형) Multitasking 이란 도대체</span><a href="#ⓔ-preemptive-선점형-multitasking-이란-도대체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>비선점형 멀티태스킹 방식(Non-preemptive)<ul><li>하나의 Task가 스케줄러부터 CPU 사용권을 할당 받았을때, <br /> Task가 자발적으로 반납할 때 까지 강제적으로 빼앗을 수 없는 멀티태스킹 방식<ul><li>비선점형 멀티태스킹 방식에서 시분할 방식을 이용해 , 모든 Task들이 동시에 실행되는 것 처럼 보이는 테크닉을 사용함<li><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbN59HX%2Fbtsibch1zg9%2F6SFGohv6nTNlsOK6gZlUyk%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbN59HX%2Fbtsibch1zg9%2F6SFGohv6nTNlsOK6gZlUyk%2Fimg.jpg" alt="nonpreemptive" loading="lazy"></a></ul><li>Wait_signal 방식이 비선점형 방식의 한 종류</ul><li>반대로 빼앗을 수 있는걸 선점형(Preemptive)이라고 함<ul><li>선점이라 먼저 점령하고 있으니 못뺏는게 아니라, <br /> B가 쓰고있는걸 A가 빼앗아 쓸 수 있다(선점 보다는 강탈)는걸로 이해하면 쉬움 <a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsTX3W%2FbtsiaYxy0fm%2FLFcj3b0REV2ZqSvw8Rsk1K%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsTX3W%2FbtsiaYxy0fm%2FLFcj3b0REV2ZqSvw8Rsk1K%2Fimg.jpg" alt="preemptive" loading="lazy"></a><li>선점 방식은 어떻게 정하느냐에 따라 다름. 우선순위, 시간 등 다양한 조건<li>Interrupt를 통해 끝남을 알림</ul></ul><h2 id="ⓕ-context-swtiching과-tcb---task의-상태변화"><span class="me-2">ⓕ Context Swtiching과 TCB - Task의 상태변화</span><a href="#ⓕ-context-swtiching과-tcb---task의-상태변화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Kernel이 어떻게 Task를 관리하는가<li>모든 Task는 자신만의 Stack과 TCB를 가짐<ul><li>TCB는 Task를 제어하기 위해 Task의 정보를 저장해놓은 자료 구조<li>스케쥴링과 문맥 교환을 위한 정보를 저장 <a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPTI2i%2FbtsibZ3OkLs%2FB5YHvFwcstskmFVVCRahD1%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPTI2i%2FbtsibZ3OkLs%2FB5YHvFwcstskmFVVCRahD1%2Fimg.jpg" alt="tcb" loading="lazy"></a></ul><li>TCB는 각 Task의 우선순위와 Stack Pointer를 가짐<li>현재 Wait, Ready 상태인 Task의 TCB의 SP는 자기가 어디까지 실행되었는지를 저장해둠<ul><li>Context가 넣어진 그 Stack의 끝(Full Descending Stack)<li>해당 Task가 실행할 때가 되면, SP가 가리키고 있던 곳의 Context를 그대로 다시 CPU의 레지스터에 복사해서 context switching을 수행</ul><li>TCB의 Status는 스케줄러에게 현재 Task의 상태를 알려주는 flag와 비슷하게 수행<ul><li>Status에 두가지 구분을 두면 그 상태를 구분할 수 있음<li>Task_A()와 Task_B()가 있을 때, wait_signal과 receive_signal이 존재<ul><li>wait_signal : 해당 Task가 일할 준비가 완료됨<li>receive_signal : B Task가 A Task에게 send_signal()이 된 signal을 A의 receive_signal에 넣어둠</ul><li>Task_A가 receive_signal과 wait_signal 두개의 값이 같으면, wait_signal의 값을 0으로 clear<ul><li>wait_signal이 0인 경우라면 스케줄러가 보기에 signal을 누군가로부터 받았고, 일할 준비가 된 ready 상태라고 판단함</ul></ul></ul><h2 id="ⓖ-tcb---task-control-block"><span class="me-2">ⓖ TCB - Task Control Block</span><a href="#ⓖ-tcb---task-control-block" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Kernel이 Task들을 관리하기 위한 Meata Data*<ul><li>메타 데이터 : 데이터의 속성들으 따로 데이터화 해놓은 데이터<ul><li>예를 들어 워드 파일에서 폰트, 글씨 색상들을 지정하여 사용자에게 주요 정보를 표현. 이런 폰트 정보들을 저장하는 것이 메타 데이터 ```c typedef struct {<br />    struct task_tcb_struct *next_ptr;<br />    struct task_tcb_struct *prev_ptr;<br /> } <strong>task_tcb_link_type</strong> ;</ul></ul></ul><p>typedef struct task_tcb_struct {<br />    char                        task_name[200];<br />    void                         <em>sp;                                  /</em> 스택 포인터 <em>/<br />    uint32               receive_siganl ;                          /</em> 받은 Signal <em>/<br />    uint32               wait_signal ;                             /</em> 기다리는 Signal   <em>/<br />    uint32               pri;                                          /</em> Task의 Priority <em>/<br />    task_tcb_link_type    link;                                   /</em> for TCB list */<br /> } <strong>task_tcb_type</strong> ;</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre>1. Task_name : 이름. 디버깅 목적으로 사람이 편하게 식별하기 위해 사용
2. sp : Stack Pointer. 각 task가 실행될 때 지역 변수 등을 저장하는 stack 고유 용도로 사용. 혹은 context switching 시에 해당 task의 context를 저장하는 용도로 사용.
3. sigs와 wait : Task끼리 주고 받는 신호들을 저장하여 Task의 state를 표현
4. Link Pointer : TCB를 double linked list로 관리할 수 있도록 함

## ⓗ Scheduler의 구현
---
- 스케줄러가 해야할 일
	1. 다음에 순서를 받을 Task 선정
	2. Context Switching. 현재 실행중인 작업을 저장하고, 다음번 순서의 작업을 가져오기
1. 다음 순서 Task 선정 방법
	- 다양한 방법 존재
	- Priority base인 경우, 우선순위대로 TCB를 linked list로 연결해놓고, head부터 처리
	- Ready Task만 따로 Ready Task List로 관리하는 방법도 존재
2. Context Switching 방법
	1. CPSR를 현재 상태 그대로 저장해야함
	2. Context를 제대로 저장해야함
	3. 현재 Task TCB의 SP가 가리키는 stack에 context를 push 한 후, update된 sp를 마지막 tcb에 저장해야함
3. 다음 New Task의 Context를 다시 CPU register에 Load하는 방법
	1. CPSR를 SPSR에 가져옴
	2. Context를 모두 가져옴
	3. SP를 복구

## ⓘ ISR은 어떻게 구현해 - 선점형과 비선점형
---
- IRQ Exception이 발생하여, IRQ Handler로 branch하여, Interrupt를 처리
- Exception vector에 저장된 IRQ_Handler의 주소로 branch.
	- IRQ_Handler 구현 시 pipe line 때문에 돌아갈 때 lr 값에서 -4를 해줘야함. 주의
	- IRQ mode로 들어서는 순간 SP는 IRQ mode의 SP를 가리키고 있음
	- IRQ mode로 들어가면, 
		1. lr 을 lr = lr-4로 보정하기
		2. 이전 mode에서 사용하던 register들을 backup.
- 인터럽트 처리 후 복귀하는 방법
	1. SPSR을 다시 CPSR로 복구. lr을 pc에 넣어준다
- 보통 시스템에 여러 인터럽트가 존재
	- SoC에 Interrupt Controller가 붙어있어, 어떤 Interrupt가 걸렸는지 확인해줌
- IRQ_Handler 내용을 너무 길게 짜면 안된다는 통설 존재
	- 보통 watchdog라는 timer를 통해 시스템이 이상해지는 것을 방지함
- 중첩 ISR은 우선순위를  이용한 Nesting을 많이 사용함

## ⓙ 선점형 Kernel에서 wait, send, clr signal의 구현과 IRQ Handler
---
- Kernel에게 현재 Task가 해야할 일과 상태를 알려주기 위한 Kernel API
	- wait_signal(), send_signal(), clr_signal()을 구현하는 방법
	- wait_signal() : Task가 스스로 CPU 점유권을 놓으면서 특정 Signal을 대기
	- send_signal() : 자신이 아닌 다른 Task에게 signal을 전송하여 작업을 시작하도록 함
	- clr_signal() : 방금 활성화 된 Running Task가 방금 받은 signal을 지워서, 곧바로 다시 받을 수 있는 환경을 만들어주겠다는 의미
![wait](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG1qUY%2FbtsijQe8JBm%2FyzfA5oWyaAMDeBAOxJkwXK%2Fimg.jpg)
- wait_signal, receive_signal을 이용해서 API 구현
![send](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdlYODV%2FbtsikVmDgly%2F6dXoK31eQ80yXzJubJZuk1%2Fimg.jpg)
- send_signal 구현

- clr_signal 구현
```c
void **clr_signal** (uint32 signal)  
{  
   uint32 tmp_signal;  
   
   signal = ~signal;  
   curr_task_tcb-&gt;receive_signal = curr_task_tcb-&gt;receive_signal &amp; signal;  
   return;  
   
}
</pre></table></code></div></div><ul><li>원하는 signal만 지우는 bit operation</ul><h2 id="ⓚ-clock-tick-isr---timer-service"><span class="me-2">ⓚ Clock tick ISR - Timer Service</span><a href="#ⓚ-clock-tick-isr---timer-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Clock Tick ISR : 정해진 시간에 한번씩 걸리는 ISR<ul><li>특정 시간 후에 어떤 작업을 시킬 때 사용</ul><li>Time service : Clock Tick ISR을 이용한 Kernel Service<li>보통 타이머 서비스를 사용할 때, 매개변수로 시간을 넘겨줌<li>Clock tick ISR이 한번 불릴 때 마다 clk_register()를 통해서 register된 call back function들의 시간을 정해진 시간만큼 빼줌<li>시간이 0이 되는 함수들(Expired된)을 Clock tick ISR에서 등록된 call back function을 직접 실행함<li>linked list에 남은 시간 순으로 callback을 연결하는 식으로 구현됨</ul><h2 id="ⓛ-atomic---critical-section-mutex-semaphore"><span class="me-2">ⓛ ATOMIC - Critical Section Mutex Semaphore</span><a href="#ⓛ-atomic---critical-section-mutex-semaphore" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>공유 데이터의 문제 : ISR과 일반 Code가 데이터를 공유하게 되면 문제가 발생함<ul><li>이를 방지하기 위해 Interrupt_lock을 걺<li>공유 데이터가 있을때, 반드시 인터럽트가 걸려서는 안되는 영역인 Atomic 영역을 사용해야함<li>Atomic 영역, 혹은 Critical Section이라고 함<li>RTOS는 Kernel service로, Task끼리 발생하는 임계영역 문제를 해결하기 위해 semaphore, mutex 등을 제공함<li>Semaphore : 철도의 신호기라는 뜻. 철로가 하나밖에 없는 구간은 하나의 기차만 이용 가능<ul><li>obtaion, release를 통해, 자원을 얻고, 반납함<li>여러 Task들이 동시에 대기하고 있을 때, 어떤 Task에게 자원을 줄지 정하는 방법들<ul><li>우선순위에 따라, 선착순 등 RTOS에 따라 다름</ul></ul><li>Mutex는 1개의 semaphore</ul></ul><h2 id="ⓜ-interrupt-vs-polling"><span class="me-2">ⓜ Interrupt VS. Polling</span><a href="#ⓜ-interrupt-vs-polling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Interrput는 Hardware의 변화를 감지해서 외부로부터의 입력을 CPU가 알아채는 방법<ul><li>하던 일을 멈추고, 미리 약속된 ISR을 실행하여, 그 변화에 대한 응답을 처리<li>각 CPU마다 Interrupt를 어떻게 처리하는지가 다름<li>CPU가 다른일을 할 수 있는 상태지만, 다시 해당 task 로 순서가 돌아오려면 시간 차이 발생(overhead)<li>거의 즉각적으로 반응함<li>Context switching이 필요함</ul><li>Polling은 하드웨어의 변화를 지속적으로 읽어들여, 그 변화를 알아채는 방법<ul><li>인터럽트와는 다르게, CPU나 RTOS에 의존하지 않고, 무작정 계속 읽어들이면 됨<li>무한정 확인하고, 완료시 종료<li>CPU가 다른 일을 하지 못하지만, 즉각적으로 상태를 알아낼 수 있음<li>polling loop가 길어질수록, 점점 더 늦게 반응함</ul></ul><h2 id="ⓝ-queue와-inter-task-communication"><span class="me-2">ⓝ Queue와 Inter Task Communication</span><a href="#ⓝ-queue와-inter-task-communication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Queue를 이용해 제어 Task가 아닌, 다른 Task들도 작업을 지시할 수 있음<li>작업을 수행하는 Task는 큐에서 하나씩 꺼내어 작업을 수행함<li>이런 Queue를 각각의 Task마다 가지고 있을 수 있게 하면, Task끼리의 통신을 Queue를 통해 가능</ul><h2 id="ⓞ-dpc나-apc-그리고-bottom-half"><span class="me-2">ⓞ DPC나 APC, 그리고 Bottom Half</span><a href="#ⓞ-dpc나-apc-그리고-bottom-half" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>할 일이 많은 ISR은 어떻게 작성해야하는가<ul><li>ISR중 너무 긴 프로시저는 ‘지금 당장 처리할 부분’과 ‘나중에 처리할 부분’ 으로 두 Stage로 나눈다</ul><li>Deferred Procedure Call, Asynchronous Procedure Call, 또는 Linux에서 말하는 Bottom half<li>Bottom Half = APC + DPC<ul><li>Asynchronous Procedure Call(APC) : 지금 처리하지 않고, 나중에 Task Level로 처리할 수 있도록 처리하는 부분<li>Deferred Procedure Call(DPC) : APC를 직접 처리하는 부분</ul><li>Callback Function을 등록해놨는데, 처리할 내용이 너무 많은 경우 -&gt; Task Level에서 실행하도록 변경<li>큐를 이용하여, call back function을 / ACP를 처리할 / DPC task의 Queue Command로 보내어 처리<ul><li>ISR routine에서 queue를 이용해서 DPC를 처리할 Task의 queue에 callback function을 넣음</ul></ul><h2 id="ⓟ-watch-dog-task"><span class="me-2">ⓟ Watch dog task</span><a href="#ⓟ-watch-dog-task" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>일반적인 임베디드 시스템에는 Watdog라는 하드웨어 타이머가 존재<ul><li>모든 Task가 제 때 응답할 수 있는지를 체크<li>문제가 있을경우, 하드웨어적으로 타겟을 리셋시키는 목적<li>기아 상태, 교착 상태 등을 체크</ul><li>Watchdog timer를 관리하는 Task 존재<ul><li>모든 Task가 제시간에 report를 보내는지 체크<li>report를 보내지 못한다면 시스템 Lock up, watchdog timer를 expire 시킴</ul><li>구현 방법<ul><li>모든 Task가 Timer Callback을 등록하여 report 할 수 있도록 구성<li>각 Task별로 필요한 시간만큼 할당<ul><li>각별한 주의가 필요한 Task는 주기를 짧게 설정<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 다른 Task들</span>
<span class="kt">void</span><span class="err"> 다른모든</span><span class="n">_task</span><span class="err"> </span><span class="p">()</span>  
<span class="p">{</span>  
<span class="err">     </span><span class="n">set_timer</span><span class="err"> </span><span class="p">(</span><span class="err">호출한 자기 자신</span><span class="p">,</span><span class="err"> </span><span class="n">DOG_REPORT_SIG</span><span class="p">,</span><span class="err"> 자기한테 알맞은 시간</span><span class="p">);</span>  
<span class="err">     </span><span class="n">wait_signal</span><span class="p">(</span><span class="n">DOG_REPORT_SIG</span><span class="p">)</span>  
<span class="err">     </span><span class="k">if</span><span class="err"> </span><span class="p">(</span><span class="n">get_signal</span><span class="err"> </span><span class="p">()</span><span class="err"> </span><span class="o">==</span><span class="err"> </span><span class="n">DOG_REPORT_SIG</span><span class="p">){</span>  
<span class="err">           </span><span class="n">send_signal</span><span class="err"> </span><span class="p">(</span><span class="n">Watchdog_task</span><span class="p">,</span><span class="err"> 자기 자신</span><span class="p">);</span><span class="err"> </span><span class="cm">/* report to watch dog task */</span>  
<span class="err">           </span><span class="n">clr_signal</span><span class="err"> </span><span class="p">(</span><span class="n">DOG_REPORT_SIG</span><span class="p">)</span>  
<span class="err">     </span><span class="p">}</span>  
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// Watchdog Task</span>
<span class="kt">void</span> <span class="nf">Watch_dog_task</span> <span class="p">()</span>  
<span class="p">{</span>  
  <span class="n">set_timer</span> <span class="p">(</span><span class="err">호출한</span> <span class="err">자기</span> <span class="err">자신</span><span class="p">,</span> <span class="n">WAKE_UP_SIG</span><span class="p">,</span> <span class="err">적당한</span> <span class="err">주기</span><span class="p">);</span>  
  <span class="n">wait_signal</span><span class="p">(</span><span class="n">WAKE_UP_SIG</span><span class="p">)</span>  
  <span class="k">if</span> <span class="p">(</span><span class="n">get_signal</span> <span class="p">()</span> <span class="o">==</span> <span class="n">WAKE_UP_SIG</span><span class="p">){</span>  
  <span class="k">for</span> <span class="p">(</span><span class="n">Task</span> <span class="err">개수</span><span class="p">){</span>  
  <span class="err">각</span> <span class="n">task</span><span class="err">의</span> <span class="err">시간을</span> <span class="n">watchdog</span><span class="err">이</span> <span class="err">일어나는</span> <span class="err">주기인</span> <span class="s">"적당한 주기"</span><span class="err">만큼</span> <span class="err">씩</span> <span class="err">빼주고</span><span class="p">,</span>
  <span class="err">빼준</span> <span class="err">값이</span> <span class="mi">0</span><span class="err">보다</span> <span class="err">작아진다면</span><span class="p">,</span> <span class="err">문제</span> <span class="err">발생</span><span class="o">!!</span>
  <span class="n">Interrupt_lock</span><span class="p">()</span><span class="err">을</span> <span class="err">걸어버리고</span> <span class="n">While</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">을</span> <span class="err">걸어</span> <span class="err">버려서</span>  
  <span class="n">Watch</span> <span class="n">dog</span> <span class="n">timer</span> <span class="n">expire</span><span class="err">가</span> <span class="err">되어</span> <span class="n">Reset</span><span class="err">을</span> <span class="err">시킨다</span>  
  <span class="n">report</span><span class="err">한</span> <span class="n">Task</span><span class="err">가</span> <span class="err">있으면</span> <span class="err">다시</span> <span class="err">원래의</span> <span class="n">interval</span><span class="err">로</span> <span class="err">값을</span> <span class="n">setting</span><span class="err">해</span> <span class="err">준다</span>  
  <span class="p">}</span>  
  <span class="n">clr_signal</span> <span class="p">(</span><span class="n">DOG_REPORT_SIG</span><span class="p">)</span>  
  <span class="p">}</span>  
<span class="p">}</span>
</pre></table></code></div></div></ul></ul></ul><h2 id="ⓠ-bootup-중-kernel로의-진입---main-함수--"><span class="me-2">ⓠ Bootup 중 Kernel로의 진입 - main() 함수 -</span><a href="#ⓠ-bootup-중-kernel로의-진입---main-함수--" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>보통 Kernel로의 진입은 main 함수에서 이루어짐<li>main 함수는 기본적인 Hardware setup-CPU, MCU, clock, memory init 이후, 순수하게 software가 동작 가능한 상태가 되었을 때 호출됨<li>kernel_init 함수를 통해 IDLE task를 살리는 일을 수행<ul><li>IDLE task란, 아무것도 ready거나, running이 아닌 상태인 경우, 커널을 점유할 task를 하나 넣는 것<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">dword</span><span class="err"> </span><span class="n">idle_stack</span><span class="err"> </span><span class="p">[</span><span class="n">IDLE_STACK_SIZ</span><span class="p">];</span><span class="err">     </span><span class="cm">/* Stack for MC task.     */</span>  
<span class="err"> </span>  
<span class="kt">int</span><span class="err"> </span><span class="o">**</span><span class="n">main</span><span class="o">**</span><span class="err"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>  
<span class="p">{</span>  
<span class="err">  </span><span class="n">kernel_init</span><span class="p">(</span><span class="err"> </span>  
<span class="err">            </span><span class="o">&amp;</span><span class="n">idle_task_tcb</span><span class="p">,</span><span class="err">             </span><span class="cm">/* IDLE task TCB */</span>  
<span class="err">            </span><span class="p">(</span><span class="kt">void</span><span class="err"> </span><span class="o">*</span><span class="p">)</span><span class="n">idle_stack</span><span class="p">,</span><span class="err">        </span><span class="cm">/* IDLE task stack */</span>  
<span class="err">            </span><span class="n">IDLE_PRI</span><span class="p">,</span><span class="err">                    </span><span class="cm">/* IDLE task PRIORITY */</span>  
<span class="err">            </span><span class="n">idle_task</span><span class="p">,</span><span class="err">                    </span><span class="cm">/* IDLE task 본체 */</span>  
<span class="err">            </span><span class="s">"IDLE_task"</span><span class="p">)</span>  
<span class="err">   </span><span class="k">return</span><span class="err"> </span><span class="mi">0</span><span class="p">;</span><span class="err">    </span><span class="cm">/* Never Returns : 여기로는 다시는 안돌아와요 */</span>  
<span class="p">}</span>
</pre></table></code></div></div></ul><li>idle_task_tcb : task tcb list에 등록 후, IDLE task를 실행하기 위함<li>idle_stack : tcb에 IDLE task가 사용하게 될 stack<li>IDLE_PRI : 우선순위<li>idle_task : task 본체<li>taskname <a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMijFS%2Fbtsic5YOJA8%2F9cXpv4kLRwDgVqnqEiS1ik%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMijFS%2Fbtsic5YOJA8%2F9cXpv4kLRwDgVqnqEiS1ik%2Fimg.jpg" alt="idletask" loading="lazy"></a><li>다음과 같은 구조로 idle task 작업 수행<ul><li>Kernel에 더이상 Task가 없는 경우, idle task를 수행함<li>보통은 Battery Saving을 위해, Task가 일을 안할 때는, Power Saving mode로 시스템을 셧다운 시킴</ul></ul><h2 id="ⓡ-kernel을-porting-한다는-것"><span class="me-2">ⓡ Kernel을 Porting 한다는 것</span><a href="#ⓡ-kernel을-porting-한다는-것" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Porting : 이미 만들어져 있는 소프트웨어를 타겟에서 동작할 수 있도록 수정한다던가, 특정 루틴을 만든다던가 해서 타겟에서 잘 동작할 수 있도록 만드는 것<li>이미 만들어져 있는 커널을 타겟에서 제대로 동작할 수 있도록 만듬<li>리눅스 커널을 예시로 들면, 리눅스 커널은 소프트웨어 그 자체로서 어느 CPU든지 컴파일만 새로 한다면 동작 할 수 있도록 구성되어 있음<ul><li>범용성이 높ㅇ느 C로 짜여있는 경우가 대부분이므로, C는 많은 CPU에서 C compiler를 제공하므로, 이를 타겟에 맞는 컴파일러로 다시 컴파일만 하면 됨</ul><li>어느 부분을 작업해야하는가 -&gt; CPU마다 다른 부분들<ol><li>Interrupt Lock / Unlock<li>Context Switching 할 때, Backup 해야하는 Context<li>Stack이 자라는 방향<li>SWI를 호출하는 방법<li>Interrupt 걸린 후 처리방법<li>ARM경우, Mode마다 사용되는 Stack<li>Watchdog Timer 또한 MCU마다 다름</ol><li>커널을 포팅하는 작업은 쉬운 작업이 아니므로, 커널이 어떻게 동작하는지, 타겟 CPU가 어떻게 동작하는지를 잘 알아야 함</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/it/">IT</a>, <a href="/categories/embedded/">Embedded</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/book/" class="post-tag no-text-decoration" >book</a> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/hardware/" class="post-tag no-text-decoration" >hardware</a> <a href="/tags/software/" class="post-tag no-text-decoration" >software</a> <a href="/tags/rtos/" class="post-tag no-text-decoration" >rtos</a> <a href="/tags/kernel/" class="post-tag no-text-decoration" >kernel</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=6.%20RTOS%20%ED%8C%A9%ED%86%A0%EB%A6%AC%20-%20Kernel%20%EC%9D%B4%EC%95%BC%EA%B8%B0%20-%20Dukgukim&url=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_6.Kernel%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=6.%20RTOS%20%ED%8C%A9%ED%86%A0%EB%A6%AC%20-%20Kernel%20%EC%9D%B4%EC%95%BC%EA%B8%B0%20-%20Dukgukim&u=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_6.Kernel%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_6.Kernel%2F&text=6.%20RTOS%20%ED%8C%A9%ED%86%A0%EB%A6%AC%20-%20Kernel%20%EC%9D%B4%EC%95%BC%EA%B8%B0%20-%20Dukgukim" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">최근 업데이트</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/gitaction/">GitHub Action</a><li class="text-truncate lh-lg"> <a href="/posts/bj-2665/">백준 2665. 미로만들기</a><li class="text-truncate lh-lg"> <a href="/posts/bj-10844/">백준 Bottom-UP DP 문제들 2</a><li class="text-truncate lh-lg"> <a href="/posts/ILI9163C&ST3375/">TFT 디스플레이 라이브러리 : ILI9163C, ST7735</a><li class="text-truncate lh-lg"> <a href="/posts/bj-dp/">백준 DP 문제들 3</a></ul></section><section><h2 class="panel-heading">인기 태그</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/bruteforce/">bruteforce</a> <a class="post-tag btn btn-outline-primary" href="/tags/bfs/">bfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/cpp/">cpp</a> <a class="post-tag btn btn-outline-primary" href="/tags/impl/">impl</a> <a class="post-tag btn btn-outline-primary" href="/tags/graph/">graph</a> <a class="post-tag btn btn-outline-primary" href="/tags/search/">search</a> <a class="post-tag btn btn-outline-primary" href="/tags/dfs/">dfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/sort/">sort</a> <a class="post-tag btn btn-outline-primary" href="/tags/dijkstra/">dijkstra</a> <a class="post-tag btn btn-outline-primary" href="/tags/protocol/">protocol</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">바로가기</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">관련된 글</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/ER_7.DeviceControl/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1720227600" data-df="YYYY/MM/DD" > 2024/07/06 </time><h4 class="pt-0 my-2">7. Device Control and System Architecture</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ Device를 control 한다는 것 ⓑ Register를 Setting 한다는 것과 Memory Mapped IO ⓒ Memory Device를 Control 한다는 것 ⓓ Bus Sizer Register와 Memory Controller - 메모리 확장구성과 CS와의 관계 ⓔ 특이한...</p></div></div></a></article><article class="col"> <a href="/posts/ER_5.software/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1717059600" data-df="YYYY/MM/DD" > 2024/05/30 </time><h4 class="pt-0 my-2">5. Software 비네팅(Vinetting)</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ Context와 AAPCS ⓑ Pointer와 Array는 소녀시대와 원더걸스 , 그리고 이중포인터 ⓒ struct와 typedef 그리고 PACKED ⓓ STACK, HEAP에 관한 소고. ⓔ Stack의 정체와 자세히 보기 - initialization까지 ⓕ 함수가 불렸을 때 일...</p></div></div></a></article><article class="col"> <a href="/posts/ER_4.ARMcontol/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1715932800" data-df="YYYY/MM/DD" > 2024/05/17 </time><h4 class="pt-0 my-2">4. ARM 미장센 - ARM 제어의 구현</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ ARM Assembly를 파헤쳐 보자 ADS vs GNU ⓑ 대충의 초간단 Assembly와 Reverse Engineering ⓒ ARM, Thumb mode와 S 접미사 ⓓ ARM과 Thumb 사이의 Veneer ⓔ Inline Assembly와 INTLOCK의 구현 ⓕ Pipe li...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/bj-3085/" class="btn btn-outline-primary" aria-label="이전 글" ><p>백준 3085. 사탕 게임</p></a> <a href="/posts/bj-1107/" class="btn btn-outline-primary" aria-label="다음 글" ><p>백준 1107. 리모콘</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/jinhg0214">Dukgukim</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다." >일부 권리 보유</span></p><p>Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.2.4" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">인기 태그</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/bruteforce/">bruteforce</a> <a class="post-tag btn btn-outline-primary" href="/tags/bfs/">bfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/cpp/">cpp</a> <a class="post-tag btn btn-outline-primary" href="/tags/impl/">impl</a> <a class="post-tag btn btn-outline-primary" href="/tags/graph/">graph</a> <a class="post-tag btn btn-outline-primary" href="/tags/search/">search</a> <a class="post-tag btn btn-outline-primary" href="/tags/dfs/">dfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/sort/">sort</a> <a class="post-tag btn btn-outline-primary" href="/tags/dijkstra/">dijkstra</a> <a class="post-tag btn btn-outline-primary" href="/tags/protocol/">protocol</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
