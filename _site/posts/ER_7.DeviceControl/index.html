<!doctype html><html lang="ko-KR" data-mode="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Device Control and System Architecture" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Embedded Recipes" /><meta property="og:description" content="Embedded Recipes" /><link rel="canonical" href="https://jinhg0214.github.io/posts/ER_7.DeviceControl/" /><meta property="og:url" content="https://jinhg0214.github.io/posts/ER_7.DeviceControl/" /><meta property="og:site_name" content="Dukgukim" /><meta property="og:image" content="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-06T10:00:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" /><meta property="twitter:title" content="Device Control and System Architecture" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-07T21:35:57+09:00","datePublished":"2024-07-06T10:00:00+09:00","description":"Embedded Recipes","headline":"Device Control and System Architecture","image":{"alt":null,"url":"https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jinhg0214.github.io/posts/ER_7.DeviceControl/"},"url":"https://jinhg0214.github.io/posts/ER_7.DeviceControl/"}</script><title>7. Device Control and System Architecture | Dukgukim</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dukgukim"><meta name="application-name" content="Dukgukim"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.32.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script src="/assets/js/dist/theme.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/ko.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.32.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.min.js?baseurl=&register=" ></script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/avatar.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a> <a class="site-title d-block" href="/">Dukgukim</a><p class="site-subtitle fst-italic mb-0">이것저것 기록 블로그</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>정보</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/jinhg0214" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">홈</a> </span> <span>7. Device Control and System Architecture</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 포스트</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">취소</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1" data-toc="true"><header><h1 data-toc-skip>7. Device Control and System Architecture</h1><div class="post-meta text-muted"> <span> 게시 <time data-ts="1720227600" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2024/07/06 </time> </span> <span> 업데이트 <time data-ts="1738931757" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2025/02/07 </time> </span><div class="mt-3 mb-3"> <a href="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" class="popup img-link preview-img shimmer"><img src="https://tistory3.daumcdn.net/tistory/6281347/skin/images/recipes_book.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/jinhg0214">Dukgukim</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4267 단어" > <em>23 분</em>읽는 시간</span></div></div></div></header><div id="toc-bar" class="d-flex align-items-center justify-content-between invisible"> <span class="label text-truncate">7. Device Control and System Architecture</span> <button type="button" class="toc-trigger btn me-1"> <i class="fa-solid fa-list-ul fa-fw"></i> </button></div><button id="toc-solo-trigger" type="button" class="toc-trigger btn btn-outline-secondary btn-sm"> <span class="label ps-2 pe-1">바로가기</span> <i class="fa-solid fa-angle-right fa-fw"></i> </button> <dialog id="toc-popup" class="p-0"><div class="header d-flex flex-row align-items-center justify-content-between"><div class="label text-truncate py-2 ms-4">7. Device Control and System Architecture</div><button id="toc-popup-close" type="button" class="btn mx-1 my-1 opacity-75"> <i class="fas fa-close"></i> </button></div><div id="toc-popup-content" class="px-4 py-3 pb-4"></div></dialog><div class="content"><p><a href="https://jinhg0214.github.io/posts/Embedded_Recipes/">Embedded Recipes</a></p><h2 id="목차"><span class="me-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><a href="https://recipes.tistory.com/373">ⓐ Device를 control 한다는 것</a><li><a href="https://recipes.tistory.com/374">ⓑ Register를 Setting 한다는 것과 Memory Mapped IO</a><li><a href="https://recipes.tistory.com/375">ⓒ Memory Device를 Control 한다는 것</a><li><a href="https://recipes.tistory.com/376">ⓓ Bus Sizer Register와 Memory Controller - 메모리 확장구성과 CS와의 관계</a><li><a href="https://recipes.tistory.com/377">ⓔ 특이한 Device Interface의 CS와 Address의 이용 - LCD</a><li><a href="https://recipes.tistory.com/378">ⓕ Shadow의 개념과 Bit operation</a><li><a href="https://recipes.tistory.com/379">ⓖ C의 조미료 MACRO Technics</a><li><a href="https://recipes.tistory.com/380">ⓗ Synchronous와 Asynchronous</a><li><a href="https://recipes.tistory.com/381">ⓘ Wait State 이야기</a><li><a href="https://recipes.tistory.com/382">ⓙ PLL과 M/N:D</a><li><a href="https://recipes.tistory.com/383">ⓚ GPIO (Tristate Buffer)의 정체와 GPIO ISR</a><li><a href="https://recipes.tistory.com/384">ⓛ DMA (Direct Memory Access) - CPU몰래 영차영차</a><li><a href="https://recipes.tistory.com/385">ⓜ Cache, Cash?</a><li><a href="https://recipes.tistory.com/386">ⓝ MMU (Memory Management Unit)</a><li>ⓞ JTAG Interface를 Control 해 보자</ul><h2 id="ⓐ-device를-control-한다는-것"><span class="me-2">ⓐ Device를 control 한다는 것</span><a href="#ⓐ-device를-control-한다는-것" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>흔히 말하는 Device란, MCU 외부에 달려있는 외부 IC를 말함</p><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG9cw5%2FbtsijW7ChLR%2FzrJt0DZYhX44DNkyV9YBbK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG9cw5%2FbtsijW7ChLR%2FzrJt0DZYhX44DNkyV9YBbK%2Fimg.jpg" alt="interface" loading="lazy"></a> 보통 다음과 같은 인터페이스들이 존재</p><ul><li>CS/ 혹은 CE/ : Chip Selection. Chip Enable<ul><li>평소에 Pull up 되어있는 핀. Low로 만들면 이 칩을 사용하겠다는 의미</ul><li>Data : 양방향 pin. 명령어, 상태 등을 MCU와 pin이 서로 전달 받는 통로<ul><li>병렬 BUS로 여러 가닥이거나, I2C나 PSI등으로 한가닥일 수 있음</ul><li>CLK : 클럭<li>이 외에도 OE/ AVD/ 등 부가적인 핀들</ul><p>외부 I/C에 명령을 내리는 과정</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1. CE/ CS/를 LOW로 설정
2. Device에 명령어 binary sequence를 data line을 통해 전송
3. Device에 명령어가 전달 되었는지 잠시 대기
4. Device가 명령어를 제대로 처리했는지 Data Line을 통해 상태를 전달 받음 (ACK)
5. CE/ CS/를 다시 HIGH로 설정
</pre></table></code></div></div><p>디바이스들 마다 다른 시퀸스가 추가되거나 변경 될 수 있음</p><p>중요한 것은 Timing Specification. 최소 대기 시간, 최대 대기 시간 등</p><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4ptFO%2FbtsiliCkobA%2F7OlKADujxCzkJ0YK3xlzIK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4ptFO%2FbtsiliCkobA%2F7OlKADujxCzkJ0YK3xlzIK%2Fimg.jpg" alt="spec" loading="lazy"></a></p><p>CLK 2개 주기 동안 일어나는 일을 예시로 듬</p><ul><li><p>CS_N (CE/)가 MCLK(메인 CLK)이 High end일때 LOW로 같이 떨어짐</p><li><p>t(ard)이후 OE_N을 LOW로 떨어트리면, DATA가 NOR Memory로 부터 출력됨</p><ul><li>t(rds1)시간 만큼 data가 유지 되어야 MCU가 DATA를 capture 할 수 있음</ul></ul><h2 id="ⓑ-register를-setting-한다는-것과-memory-mapped-io"><span class="me-2">ⓑ Register를 Setting 한다는 것과 Memory Mapped IO</span><a href="#ⓑ-register를-setting-한다는-것과-memory-mapped-io" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>Register를 세팅한다는 건 무슨 말일까</p><p>Device들의 User Manual이나 Data sheet를 보면, Software interface로 Register book을 제공함</p><p>엄청나게 많은 Register들과 그것들의 주소, 각 bit들의 의미를 나열해 둠</p><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbk8oGm%2FbtsikBCa78i%2FPRKa7rZXhcSNU4tcmUCNm1%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbk8oGm%2FbtsikBCa78i%2FPRKa7rZXhcSNU4tcmUCNm1%2Fimg.jpg" alt="mcu" loading="lazy"></a></p><p>PWR_CFG라는 레지스터를 예시로 설명</p><ul><li>주소는 0x7E00F804<li>R/W 가능<li>처음 리셋 되었을 때 value는 0x00000001<li>32bit</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbf2rp5%2FbtsikADeXze%2FtQUuC1dHOOqDEakjh5R7FK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbf2rp5%2FbtsikADeXze%2FtQUuC1dHOOqDEakjh5R7FK%2Fimg.jpg" alt="pwg_CFG" loading="lazy"></a></p><p>각 비트에 대한 설명. 이런식으로 각 비트가 어떤식으로 사용되는지 표기됨</p><p>즉, Register를 설정한다는 것은 1) 설정하고자 하는 Register의 주소에 2) 설정하고자 하는 값을 쓰는 것</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dword</span>  
<span class="k">volatile</span> <span class="n">dword</span> <span class="o">*</span><span class="n">pwr_cfg</span><span class="p">;</span>  
<span class="n">pwr_cfg</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">dword</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x7E00F804</span>  
  
<span class="kt">void</span> <span class="nf">set_pwr_cfg</span><span class="p">(</span><span class="n">dword</span> <span class="n">value</span><span class="p">)</span>  
<span class="p">{</span>  
	<span class="o">*</span><span class="n">pwr_cfg</span> <span class="o">=</span> <span class="n">value</span>  
<span class="p">}</span>

<span class="n">set_pwr_cfg</span><span class="p">(</span><span class="mh">0x800</span><span class="p">);</span>
</pre></table></code></div></div><p>주의. Register의 크기만큼씩 Access 가능함</p><h2 id="ⓒ-memory-device를-control-한다는-것"><span class="me-2">ⓒ Memory Device를 Control 한다는 것</span><a href="#ⓒ-memory-device를-control-한다는-것" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>메모리 디바이스를 컨트롤 한다는 것은, 양방향 디바이스를 컨트롤 한다는 것과 같음</p><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnc0oR%2FbtsijOobAi5%2F6vBmm8KZfJCNDk1MIuivBk%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fnc0oR%2FbtsijOobAi5%2F6vBmm8KZfJCNDk1MIuivBk%2Fimg.jpg" alt="device" loading="lazy"></a></p><p>RAM 의 기본 모양. 24개의 Address line, 16개의 Data line, CS/ OE/(output enable)</p><ul><li>16개의 data line -&gt; 한번에 16bit씩 읽을 수 있음<li>24개의 address line -&gt; 2^24 만큼의 주소 구별<li>총 16MB의 크기<li>OE/(output enable) : Output 설정시, 메모리 입장에서는 출력(Output). Input설정 시 쓰기(Write)</ul><p>메모리 읽기</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1. CE/를 LOW로 설정
2. OE를 High로 설정 
3. Address Line에 읽기 원하는 주소를 binary 형태로 설정
4. Data line에 뜬 16bit data를 읽어감
5. CE/를 High로 설정
</pre></table></code></div></div><p>메모리 쓰기</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1. CE/를 LOW로 설정
2. OE를 LOW로 설정
3. Address Line에 읽기 원하는 주소를 binary 형태로 설정
4. Data Line에 16bit Data 쓰기
5. CE/를 HIGH로 설정
</pre></table></code></div></div><h2 id="ⓓ-bus-sizer-register와-memory-controller---메모리-확장구성과-cs와의-관계"><span class="me-2">ⓓ Bus Sizer Register와 Memory Controller - 메모리 확장구성과 CS와의 관계</span><a href="#ⓓ-bus-sizer-register와-memory-controller---메모리-확장구성과-cs와의-관계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>기본적인 메모리 시스템 구조는 MCU 내부에 CPU core, 이를 위한 Memory controller가 있고, 이를 통해 외부의 메모리에 접근, 읽기/ 쓰기 동작 수행함</p><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEwPcq%2FbtsitzK5mEu%2FCDNxdfsvDrcekbIcXlru2K%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEwPcq%2FbtsitzK5mEu%2FCDNxdfsvDrcekbIcXlru2K%2Fimg.jpg" alt="mc" loading="lazy"></a></p><p>코어에서 메모리를 제어하기 위해 발생시킬 수 있는 신호 존재</p><p><code class="language-plaintext highlighter-rouge">A[31:0]</code>: 32 bit짜리 Address</p><p><code class="language-plaintext highlighter-rouge">D[31:0]</code>: WORD 사이즈 데이터</p><p>nRD : OE에 관계된 Read하겠다는 신호</p><p>nWR : 마찬가지로 Write하겠다는 신호</p><p>nWait : 외부 메모리가 Processor보다 느릴 경우, 프로세서를 대기시키는 신호</p><p>한번에 16bit Data Access 가능. Address의 경우, 4GB를 만들어 낼 수 있음</p><ul><li>2byte의 칸이 2^32개 존재 -&gt; 2^33 byte -&gt; 2^30 바이트는 1GB이므로, 총 8GB</ul><p>실제 메모리가 64MB 짜리가 달려있다면, Address line은 26개, Data line은 8개로 바꿔주는 회로가 별도로 필요</p><p>이게 Memory Controller, Bus Sizer임</p><h2 id="ⓔ-특이한-device-interface의-cs와-address의-이용---lcd"><span class="me-2">ⓔ 특이한 Device Interface의 CS와 Address의 이용 - LCD</span><a href="#ⓔ-특이한-device-interface의-cs와-address의-이용---lcd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>LCD 또한 Interface를 가지고 있음 LCD의 메모리맵 예시</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>0x00000000 SDRAM_CS0_N 32MB
0x08000000 SDRAM_CS1_N 32MB
...
0x20000000 LCD_CD_N 3MB
</pre></table></code></div></div><ul><li>SDRAM 사용. 32MB까지 Access 가능. Chipselect 는 Low Active 등<li>LCD는 0x2000000번지에 3MB만큼의 address 영역을 가지고 있음<ul><li>0x20000000 번지부터 3MB 사이의 주소를 Access 하면, LCD의 chip select를 사용할 수 있음</ul></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd4zuf5%2FbtsisnR0MDj%2FFoeARMHaI1kbh3FBsJA340%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd4zuf5%2FbtsisnR0MDj%2FFoeARMHaI1kbh3FBsJA340%2Fimg.jpg" alt="lcd" loading="lazy"></a></p><p>LCD Controller는 3개의 Input을 가짐. CS/, ADS, Data</p><ul><li>CS/ : Chip Select. LCD 사용 시 LOW<li>ADS : 현재 데이터가 command인지, data인지 여부<li>Data : 0x20000000 ~ 0x202FFFF 사이의 주소를 Access하면, 자동으로 LCD_CS_N이 LOW로 떨어짐. Command를 주고 싶을 때는 LCD Controller의 ADS에 High를, Data를 주고 싶을 때는 Low를 주면 됨</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#define Main_LCD_Write_cmd (cmd)   (*(volatile word *)(0x200000080) = cmd  
#define Main_LCD_Write_data (data)   (*(volatile word *)(0x200000000) = data  
</span>   
<span class="n">Main_LCD_Write_cmd</span> <span class="p">(</span><span class="mh">0xABCD</span><span class="p">);</span>  
<span class="n">Main_LCD_Write_data</span> <span class="p">(</span><span class="mh">0x1234</span><span class="p">);</span>
</pre></table></code></div></div><p>LCD Controller 내부의 RAM을 GRAM이라 부름</p><h2 id="ⓕ-shadow의-개념과-bit-operation"><span class="me-2">ⓕ Shadow의 개념과 Bit operation</span><a href="#ⓕ-shadow의-개념과-bit-operation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Shadow : 쓰기만 가능한 레지스터들을 전역변수에 backup해 두고, 읽을 수 있게 하는 개념<ul><li>대부분 Register에 많이 사용함.</ul><li>Register는 Bit별로 설정이 가능한 Latch이므로, Bit 연산자를 주로 사용함<li>LSB로부터 6번째 bit가 어떤 값인지 확인하고 싶다면<ol><li><code class="language-plaintext highlighter-rouge">if(reg_data &amp; 0x20)</code>로 6번째 값을 확인 가능.<ul><li>이런 0x20값을 Mask라고 함</ul><li>혹은 Shift 연산자를 이용해 원하는 bit 값을 빼냄. <code class="language-plaintext highlighter-rouge">if(reg_data &gt;&gt; 6 &amp; 0x1)</code> 혹은 <code class="language-plaintext highlighter-rouge">if(reg_data &amp; (1&lt;&lt;6))</code></ol><li>반대로 값을 설정하거나, Clear 하거나, 반전 시키는것도 가능<li>설정할 때는<ul><li><code class="language-plaintext highlighter-rouge">reg_data = reg_data | 0x80</code> 혹은 <code class="language-plaintext highlighter-rouge">reg_data = reg_data = reg_data | (0x1 &lt;&lt; 3)</code></ul><li>clear할 때는<ul><li><code class="language-plaintext highlighter-rouge">reg_data &amp;= ~(1&lt;&lt;3)</code></ul><li>반전 시킬때는 XOR을 이용<ul><li><code class="language-plaintext highlighter-rouge">reg_data ^= (1&lt;&lt;3)</code></ul><li>비트 필드를 사용하여 bit 단위로 관리 가능</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  
	<span class="n">int32</span> <span class="n">flag</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>   <span class="cm">/* flag 3 bit */</span>  
    <span class="n">data_1</span> <span class="o">:</span> <span class="mi">20</span> <span class="p">;</span>  <span class="cm">/* data_1 : 20 bit */</span>  
    <span class="n">data_2</span> <span class="o">:</span> <span class="mi">9</span> <span class="p">;</span>   <span class="cm">/* data_2 : 9 bit */</span>  
<span class="p">}</span> <span class="n">REGISTER_SHADOW</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="ⓖ-c의-조미료-macro-technics"><span class="me-2">ⓖ C의 조미료 MACRO Technics</span><a href="#ⓖ-c의-조미료-macro-technics" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>Register 설정 등을 Macro를 통해 쉽게 관리 가능</p><li><p>여러줄을 매크로로 설정하는법</p></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define CRITICAL_IO_IN() \  
</span><span class="n">critical_section_in</span><span class="p">();</span> <span class="err">\</span>  
<span class="n">ret</span> <span class="o">=</span> <span class="n">io_read</span> <span class="p">();</span> <span class="err">\</span>  
<span class="n">critical_section_out</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>Macro도 인자를 받을 수 있음</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define CRITICAL_IO_IN (CURRENT, IO, PREVIOUS) \  
</span><span class="n">critical_section_in</span><span class="p">(</span><span class="n">DEVICE_</span><span class="err">##</span><span class="n">CURRENT</span><span class="err">##</span><span class="n">_BUFFER</span><span class="p">);</span> <span class="err">\</span>  
<span class="n">ret</span> <span class="o">=</span> <span class="n">io_read</span> <span class="p">(</span><span class="n">IO_</span><span class="err">##</span><span class="n">IO</span><span class="err">##</span><span class="n">_NUM</span><span class="p">);</span> <span class="err">\</span>  
<span class="n">critical_section_out</span><span class="p">(</span><span class="n">DEVICE_</span><span class="err">##</span><span class="n">PREVIOUS</span><span class="err">##</span><span class="n">_BUFFER</span><span class="p">);</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">##</code>를 이용해 Argument를 넣을 수 있음</p><p><code class="language-plaintext highlighter-rouge">CRITICAL_IO_IN (CURRENT, IO, PREVIOUS);</code> 를 호출하면</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">critical_section_in</span><span class="p">(</span><span class="n">DEVICE_BOOTUP_BUFFER</span><span class="p">);</span>  
<span class="n">ret</span> <span class="o">=</span> <span class="n">io_read</span> <span class="p">(</span><span class="n">IO_USB_NUM</span><span class="p">);</span>  
<span class="n">critical_section_out</span><span class="p">(</span><span class="n">DEVICE_STARTUP_BUFFER</span><span class="p">);</span>
</pre></table></code></div></div><p>과 같이 자동으로 변환됨</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp">#define DEVICE_BOOTUP_BUFFER 1  
#define DEVICE_STARTUP_BUFFER 3  
#define IO_USB_NUM 2
</span></pre></table></code></div></div><p>가 선언되어있다면</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">critical_section_in</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  
<span class="n">ret</span> <span class="o">=</span> <span class="n">io_read</span> <span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
<span class="n">critical_section_out</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></table></code></div></div><p>로 자동으로 변환됨</p><ul><li>예시 ) 이를 응용하여 Register control 하는법<ul><li>MUC의 clock을 설정할 수 있는 주소가 0xC000CB00, 32bit reegister. LSB bit 2, 3이 MCU의 Data이고 R/W가 가능한 레지스터.<li>0x0 : disable, 0x1 : enabble, 0x2 : Clock의 주기를 반으로, 0x3 : Clock의 주기를 두배로</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#define HWCIO_MCU_CLK_ADDR 0xC000CB00  // 주소
#define HWCIO_MCU_CLK_MSK 0x3   // 마스킹
#define HWCIO_MCU_CLK_SHIFT 0x2   // 
</span>
<span class="c1">// 설정 </span>
<span class="cp">#define HWCIO_MCU_CLK_DIS_VALUE 0x0  
#define HWCIO_MCU_CLK_EN_VALUE 0x1  
#define HWCIO_MCU_CLK_TWICE_VALUE 0x3  
#define HWCIO_MCU_CLK_HALF_VALUE 0x2  
</span></pre></table></code></div></div><p>다음과 같이 매크로 정의 후,</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#define IO_OUT (target, val) \  
</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">dword</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">HWCIO_</span><span class="err">##</span><span class="n">target</span><span class="err">##</span><span class="n">_ADDR</span><span class="p">))</span> <span class="o">=</span><span class="err">\</span>  
<span class="p">((</span><span class="n">dword</span><span class="p">)</span> <span class="p">(</span><span class="n">HWCIO_</span><span class="err">##</span><span class="n">target</span><span class="err">##</span><span class="n">_</span><span class="err">##</span><span class="n">val</span><span class="err">##</span><span class="n">_VALUE</span> <span class="o">&amp;</span> <span class="n">HWCIO_</span><span class="err">##</span><span class="n">target</span><span class="err">##</span><span class="n">_MSK</span><span class="err">\</span>  
<span class="p">)</span><span class="o">&lt;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">IO_OUT(MCU_CLK, MCU_CLK_TWICE);</code>를 호출하면</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span> <span class="n">dword</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">HWCIO_MCU_CLK_ADDR</span><span class="p">))</span> <span class="o">=</span><span class="err">\</span>  
<span class="p">((</span><span class="n">dword</span><span class="p">)</span> <span class="p">(</span><span class="n">HWCIO_MCU_CLK_TWICE_VALUE</span> <span class="o">&amp;</span> <span class="n">HWCIO_MCU_CLK_MSK</span><span class="err">\</span>  
<span class="p">)</span><span class="o">&lt;</span>
</pre></table></code></div></div><p>로 자동으로 MCU_CLK으로 치환되어 호출됨</p><ul><li>do while을 이용한 MACRO</ul><h2 id="ⓗ-synchronous와-asynchronous"><span class="me-2">ⓗ Synchronous와 Asynchronous</span><a href="#ⓗ-synchronous와-asynchronous" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>MCU Clock과 동기가 맞는지 아닌지 여부<li>MCU로 부터 Clock 신호가 붙어있으면 Synchronous, 아니라면 Asynchronous<li>Synchronous는 MCU와 제때 Data를 원할하게 주고 받을 수 있음<li>Asynchronous는 Latency 가 발생할 수 있음</ul><h2 id="ⓘ-wait-state-이야기"><span class="me-2">ⓘ Wait State 이야기</span><a href="#ⓘ-wait-state-이야기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>MCU가 자신보다 느린 메모리 장치를 다룰 때, Wait State라는 방법을 사용함<li>RD/를 구동ㅅ킨 후에 일정 시간이 지나야 제대로 된 Data값을 돌려준다면, 일정시간 대기해야함<ul><li>제대로 된 값을 돌려주기로 기대하는 시간이 Wait State</ul><li>보통 Device Specification에 몇 clock 이후 제대로 된 Data가 나온다고 명시되어있음<li>최소 Wait State를 잘 설정해주어야 메모리가 최대 성능을 낼 수 있음</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcoVurX%2Fbtsis0CFbR9%2Fjd0GT657wrdqU0ZfKIuYx0%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcoVurX%2Fbtsis0CFbR9%2Fjd0GT657wrdqU0ZfKIuYx0%2Fimg.jpg" alt="tce" loading="lazy"></a></p><ul><li>NOR Memory의 Device Spec 예시<ul><li>tCE 가 Low로 설정된 후, 일정 시간 후 DQ에 valid data output이 제공됨</ul></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLR1OW%2FbtsisPuAppd%2FNCaZjKp3vjvSHZymJHJRn0%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLR1OW%2FbtsisPuAppd%2FNCaZjKp3vjvSHZymJHJRn0%2Fimg.jpg" alt="dq" loading="lazy"></a></p><ul><li>tCE Min이 80이라고 서렴ㅇ되어있음. 80ns이후, data가 확실하게 나옴<li>MCU에서 tACSDV 예시<ul><li>tACSDV = (T-21) + WT 라고 설명되어있다면<li>최소한 80ns를 기다려야하고, (T-21) + WT가 최소한 80ns가 되어야 한다는 뜻<li>T는 CPU Clock의 주파수 주기<ul><li>시스템이 40MHz짜리 시스템이라면, T = 1/40MHz = 0.25 * 10^-7 = 25ns<li>T-21 + WT &gt; 80ns 에 대해 정리하면,<li>W x 25 &gt; 76<li>Wait State는 정수이므로 3은 fail, 4는 pass</ul></ul></ul><h2 id="ⓙ-pll과-mnd"><span class="me-2">ⓙ PLL과 M/N:D</span><a href="#ⓙ-pll과-mnd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Clock은 PLL이라는 회로를 통해, 일정한 주파수를 생성 함<ul><li>PLL(Phase Locked Loop)</ul><li>기준 주파수인 TCXO를 통해서 원하는 주파수의 Clock을 생성함</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbYiV92%2FbtsitAKLutM%2FZp1YjlEk1uDHgdKOaKef20%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbYiV92%2FbtsitAKLutM%2FZp1YjlEk1uDHgdKOaKef20%2Fimg.jpg" alt="pll" loading="lazy"></a></p><ul><li>100MHz 주파수를 생성하기 위한 필요 회로<li>VCO : Voltage Controlled Oscillator를 통해 원하는 주파수 전압을 생성함<ul><li>VCO만 쓰면 주위 환경에 대한 변덕이 심해져서, VCO output을 sampling함</ul></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiR3Ng%2FbtsizcuLsQ5%2FJhWLmzqlhZiez1tGoOv1y0%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbiR3Ng%2FbtsizcuLsQ5%2FJhWLmzqlhZiez1tGoOv1y0%2Fimg.jpg" alt="ppl2" loading="lazy"></a></p><ul><li>MCU 내부에 안정적인 주파수를 생성해 내는 on-chip PPL이 다수 존재</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkT25w%2FbtsiBNBuJgK%2F1d9IXzrkuJV6S5wSqjbKc1%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkT25w%2FbtsiBNBuJgK%2F1d9IXzrkuJV6S5wSqjbKc1%2Fimg.jpg" alt="mnd" loading="lazy"></a></p><ul><li>M:N/D counter를 이용한 clock 구성<ul><li>M배, 1/N배 하여 원하는 clock을 구성함</ul><li>Clock Register 중에서 Source를 여러가지 준비해두어, 고를 수 있도록 제공하는 경우도 있음<li>이를 다시 M:N/D 할 수 있음</ul><h2 id="ⓚ-gpio-tristate-buffer의-정체와-gpio-isr"><span class="me-2">ⓚ GPIO (Tristate Buffer)의 정체와 GPIO ISR</span><a href="#ⓚ-gpio-tristate-buffer의-정체와-gpio-isr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>GPIO : General Purpose I/O<ul><li>정해진 기능이 없이, 사용자가 원하는대로 I/O로 사용할 수 있는 pin들<ul><li>가끔 정해진 기능이 있을때도 있는데, 이를 Alternative Functionality</ul></ul><li>ARM base의 MCU 입장에서의 GPIO는 AMBA bus에 연결된 SOC Peripheral. APB에 연결된 Slave<li>I/O는 3가지 Register를 통해 Programmable함<ol><li>Pin Mode를 결정<li>Pin의 상태를 활성화 하면서, Data direction을 결정<li>READ/WRITE 시작</ol></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMhsnV%2FbtsiuselQqL%2FW26bHphTvOjT6Iep7JOG40%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FMhsnV%2FbtsiuselQqL%2FW26bHphTvOjT6Iep7JOG40%2Fimg.jpg" alt="3buf" loading="lazy"></a></p><ul><li>GPIO는 하드웨어적으로 3상태 버퍼로 구현됨<ul><li>3상태 버퍼는 (0, 1, High Impedance)의 상태를 가짐<li>Switch 가 1일때는 I가 0에 그대로 전달됨<li>Switch 가 0일 때는 회로가 열려 Open된 것처럼 보임. 이것이 Hi-Impedance.<ul><li>연결된 부분이 끊어져 서로 연관성이 없어짐</ul></ul></ul><h2 id="ⓛ-dma-direct-memory-access---cpu몰래-영차영차"><span class="me-2">ⓛ DMA (Direct Memory Access) - CPU몰래 영차영차</span><a href="#ⓛ-dma-direct-memory-access---cpu몰래-영차영차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqpFgW%2FbtsiuB9XdWL%2F2o8ssFMLsRKkiq4JbOpHy1%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqpFgW%2FbtsiuB9XdWL%2F2o8ssFMLsRKkiq4JbOpHy1%2Fimg.jpg" alt="dma" loading="lazy"></a></p><ul><li>두 개의 Hardware Device 간의 데이터 블럭을 Transfer 하는 방법</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkN1vA%2FbtsiBLKrqBc%2FZ5ZFvORhVdk05xHQFkmMpK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkN1vA%2FbtsiBLKrqBc%2FZ5ZFvORhVdk05xHQFkmMpK%2Fimg.jpg" alt="dmac" loading="lazy"></a></p><ul><li>CPU와 상관없이 전송하는 것이 DMA. 실제 CPU는 DMAC(DMA Controller)를 Control함<li>CPU는 DMAC에게 SRC, DST, 전송할 바이트 수를 알려줌<li>DMAC는 이를 수행하고, 완료되면 CPU에 INT로 알려줌</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsqMNA%2FbtsiFQdBitG%2FQwO9vtHoScCDL1d1g3d6LK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsqMNA%2FbtsiFQdBitG%2FQwO9vtHoScCDL1d1g3d6LK%2Fimg.jpg" alt="dmac2" loading="lazy"></a></p><ul><li>DMAC는 여러가지 Register들을 가짐<ul><li>Source Register, Destination Register, Counter Register, Control Register, 전송 시작 명령을 내릴 수 있는 bit, 어떤 방식으로 전송할 것인지를 정하는 bit 등</ul><li>두가지 Transfer Mode</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbBmbzH%2FbtsiFO7VD5R%2FCbphQRtpXyRRKG6AnFPRLK%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbBmbzH%2FbtsiFO7VD5R%2FCbphQRtpXyRRKG6AnFPRLK%2Fimg.jpg" alt="stm" loading="lazy"></a></p><ul><li>Single Transfer Mode : 한번에 읽기 쓰기를 한번씩 수행. Counter를 1씩 줄임</ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbLpoDj%2FbtsizdtFW71%2FINNLhD0H2Vv8kzRrM2wOP0%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbLpoDj%2FbtsizdtFW71%2FINNLhD0H2Vv8kzRrM2wOP0%2Fimg.jpg" alt="btm" loading="lazy"></a></p><ul><li>Burst Address Mode : 시작하면 끝까지 READ/WRITE를 무한반복<li>성능은 Burst Address Mode가 더 좋지만, BUS를 계속 장악하는 문제가 있을수도 있어 single Transfer mode를 사용하기도 함</ul><h2 id="ⓜ-cache-cash"><span class="me-2">ⓜ Cache, Cash?</span><a href="#ⓜ-cache-cash" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>소프트웨어의 특성<ol><li>Temporal Locality : 소프트웨어가 한번 어떤 메모리의 상의 주소를 접근하면, 자주 접근하는 특성<li>Spatial Locality : 프로그램 실행 시, 접근하는 메모리의 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다</ol><li>이 두가지 특성을 이용하여 느린 메모리의 속도를 개선하고자 캐시를 이용함<li>Cache Hit, Cache Miss<ul><li>Hit : 내가 사용하고자 하는 데이터가 캐시에 있는 경우<li>Miss : 반대로 없는 경우</ul><li>Cache Controller가 Hit/ Miss / LRU를 담당<li>Cache Memory가 데이터 저장을 담당함<li>캐시에 Write buffer를 두어 쓰기 성능을 개선한 캐시도 있음<ul><li>Write Through : 메모리에 뭔가를 쓸 때, 캐시와 메모리 모두 갱신하여 일치시킴<li>Write Back : 메모리에는 쓰지 않고, 캐시에만 업데이트 하는 방법. Inconsistency가 발생하지만, 속도가 빠르다</ul><li>Cache clean, Flush 등을 이용해 Inconsistency가 의심되면 캐시를 비움</ul><h2 id="ⓝ-mmu-memory-management-unit"><span class="me-2">ⓝ MMU (Memory Management Unit)</span><a href="#ⓝ-mmu-memory-management-unit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>Memory Management Unit<ul><li>CPU에게 논리적 주소를 물리적 주소로 변환해줌<li>CPU가 논리적 주소를 발생시키면, MMU가 물리적 메모리의 주소로 바꿔주어 실제 물리적 메모리를 접근함</ul><li>쓰는 이유?<ol><li>Task, Program마다 똑같은 주소를 사용하기 위해 사용함<ul><li>물리적으로 <code class="language-plaintext highlighter-rouge">0x3000~0x5FFF</code>에 올라온 Task A나, <code class="language-plaintext highlighter-rouge">0x6000~0x8FFF</code>에 올라온 Task B나, <code class="language-plaintext highlighter-rouge">0x3000~0x5FFF</code>로 논리적으로 사용 가능함</ul><li>RAM의 물리적 주소가 나뉘어 있어도, 연속적인 것 처럼 보이게 할 수 있음<li>물리적 메모리에 남은 조각들을 모아서, 연속적인 Memory처럼 사용 가능<li>메모리의 특성을 조작 가능<ul><li>캐시, 논캐시 영역, Write Bufferable, Non-Write Bufferable, Read-only 등</ul></ol><li>MCU Register 구성 요소<ol><li>Virtual Addres와 Physical Address를 연결해주는 Table 필요 : Page Table<li>Table이 존재하는 위치 : Tranlation Table Base Address(TTB)</ol></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI82yS%2FbtsiuMDBvAw%2FWG8NsQ9vaqBGlKWfHkHeR1%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI82yS%2FbtsiuMDBvAw%2FWG8NsQ9vaqBGlKWfHkHeR1%2Fimg.jpg" alt="mmu" loading="lazy"></a></p><ul><li>과정<ol><li>CPU에서 어딘가에 접근하기 위해 Virtual Address를 발생<li>MMU는 이 Virtual Address 를 받아서, Memory의 TTB에서 시작해서 존재하는 Page Table을 Access<li>찾아간 Page Table 안에 Physical Address 를 찾아내서 주소 신호를 발생<li>Memory는 해당 Physical Address 안의 Data를 출력하여 CPU에게 전달</ol></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXFja0%2FbtsiuKsg104%2FB8JgKHMdz7TiNNSDod5thk%2Fimg.jpg" class="popup img-link shimmer"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXFja0%2FbtsiuKsg104%2FB8JgKHMdz7TiNNSDod5thk%2Fimg.jpg" alt="pageTable" loading="lazy"></a></p><ul><li>Page Table의 크기는 얼마나 될까?<ul><li>Virtual Address는 32Bit Address System이므로 2^32 = 4GB를 나타낼 수 있음<li>Page Table역시 4GB를 나타낼 수 있어야 하므로, Page Table 의 한개 Entry(32bit)는 1MB씩을 가리킬 수 있음<li>이러한 Entry가 4096개 필요하므로, <code class="language-plaintext highlighter-rouge">4096개 * 32bit = 16KB</code>가 테이블의 기본 크기가 됨<li>이러한 1MB 단위를 Section이라하고, 더 작은 단위로 나눌 수 있는 Fine, Coarse page Table도 존재</ul><li>Virtual Address는 어떻게 Physical Address로 변환되는가?<ul><li>끝의 2bit에 따라 Page Table Entry 의 종류가 다름<li>이러한 종류를 보고, 베이스 주소를 따라가보면 물리적 주소가 나온다</ul></ul><h2 id="ⓞ-jtag-interface를-control-해-보자"><span class="me-2">ⓞ JTAG Interface를 Control 해 보자</span><a href="#ⓞ-jtag-interface를-control-해-보자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>JTAG(Joint Test Access Group)<ul><li>Boundary Scan 구조를 통해 모든 핀들의 상태를 조사<ul><li>Boundary : CPU외부와 내부를 구분짓는 곳. 이 경계를 조사하여 상태를 알아냄</ul><li>CPU에서 나오는 모든 핀들의 상태를 알 수 있음<li>해당 핀에 강제적으로 값을 인가하여 디버깅도 가능함</ul><li>탄생 배경<ul><li>하드웨어 집적도가 높아지고, 하드웨어 테스트 중, 핀들의 상태를 조사하는 것이 어려워짐<li>CPU에서 외부로 연결되는 모든 하드웨어 핀들에 상태를 자동으로 조사할 수 있게 만들자는 아이디어에서 탄생</ul><li>JTAG Interface<ul><li>TDI, TDO, TMS, TCK, TRST 다섯개의 핀을 기본으로 가짐<ul><li>Serial 통신</ul><li>TDI, TDO : JTAG interface와 Test Data input과 Test Data Output. Data를 외부와 주고받을 수 있는 통로<li>TMS : Test Mode Select. JTAG Interface의 상태 설정<li>TCK, TRST : Clock, Reset<ul><li>Synchronous 통신</ul></ul><li>IDCODE를 읽어오는 예시<ul><li>일반적인 Serial Device Control과 유사함<ol><li>TAP Controller를 소프트웨어적으로 리셋함<li>TAP Controller에게 명령을 내리겠다고 알려줌<li>IDCODE를 읽어오겠다는 명령 발생<li>TAP Controller에게 실행 명령<li>TAP Controller에게 Data 수신 준비 완료 알림<li>IDCODE 읽어오기<li>TAP Controller를 대기상태로 변환</ol></ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/it/">IT</a>, <a href="/categories/embedded/">Embedded</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/book/" class="post-tag no-text-decoration" >book</a> <a href="/tags/study/" class="post-tag no-text-decoration" >study</a> <a href="/tags/hardware/" class="post-tag no-text-decoration" >hardware</a> <a href="/tags/software/" class="post-tag no-text-decoration" >software</a> <a href="/tags/device/" class="post-tag no-text-decoration" >device</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a> <a href="/tags/clock/" class="post-tag no-text-decoration" >clock</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=7.%20Device%20Control%20and%20System%20Architecture%20-%20Dukgukim&url=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_7.DeviceControl%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=7.%20Device%20Control%20and%20System%20Architecture%20-%20Dukgukim&u=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_7.DeviceControl%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fjinhg0214.github.io%2Fposts%2FER_7.DeviceControl%2F&text=7.%20Device%20Control%20and%20System%20Architecture%20-%20Dukgukim" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">최근 업데이트</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/gitaction/">GitHub Action</a><li class="text-truncate lh-lg"> <a href="/posts/bj-2665/">백준 2665. 미로만들기</a><li class="text-truncate lh-lg"> <a href="/posts/bj-10844/">백준 Bottom-UP DP 문제들 2</a><li class="text-truncate lh-lg"> <a href="/posts/ILI9163C&ST3375/">TFT 디스플레이 라이브러리 : ILI9163C, ST7735</a><li class="text-truncate lh-lg"> <a href="/posts/bj-dp/">백준 DP 문제들 3</a></ul></section><section><h2 class="panel-heading">인기 태그</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/bruteforce/">bruteforce</a> <a class="post-tag btn btn-outline-primary" href="/tags/bfs/">bfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/cpp/">cpp</a> <a class="post-tag btn btn-outline-primary" href="/tags/impl/">impl</a> <a class="post-tag btn btn-outline-primary" href="/tags/graph/">graph</a> <a class="post-tag btn btn-outline-primary" href="/tags/search/">search</a> <a class="post-tag btn btn-outline-primary" href="/tags/dfs/">dfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/sort/">sort</a> <a class="post-tag btn btn-outline-primary" href="/tags/dijkstra/">dijkstra</a> <a class="post-tag btn btn-outline-primary" href="/tags/protocol/">protocol</a></div></section></div><div class="toc-border-cover z-3"></div><section id="toc-wrapper" class="invisible position-sticky ps-0 pe-4 pb-4"><h2 class="panel-heading ps-3 pb-2 mb-0">바로가기</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">관련된 글</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/ER_6.Kernel/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1718074800" data-df="YYYY/MM/DD" > 2024/06/11 </time><h4 class="pt-0 my-2">6. RTOS 팩토리 - Kernel 이야기</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ RTOS와 Kernel ⓑ Embedded Software는 무한 Loop ⓒ Task 구조와 Signal ⓓ Task 상태, Task는 Service단위 ⓔ Preemptive (선점형) Multitasking 이란 도대체 ⓕ Context Swtiching과 TCB - Task의 ...</p></div></div></a></article><article class="col"> <a href="/posts/ER_5.software/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1717059600" data-df="YYYY/MM/DD" > 2024/05/30 </time><h4 class="pt-0 my-2">5. Software 비네팅(Vinetting)</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ Context와 AAPCS ⓑ Pointer와 Array는 소녀시대와 원더걸스 , 그리고 이중포인터 ⓒ struct와 typedef 그리고 PACKED ⓓ STACK, HEAP에 관한 소고. ⓔ Stack의 정체와 자세히 보기 - initialization까지 ⓕ 함수가 불렸을 때 일...</p></div></div></a></article><article class="col"> <a href="/posts/ER_4.ARMcontol/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1715932800" data-df="YYYY/MM/DD" > 2024/05/17 </time><h4 class="pt-0 my-2">4. ARM 미장센 - ARM 제어의 구현</h4><div class="text-muted"><p>Embedded Recipes 목차 ⓐ ARM Assembly를 파헤쳐 보자 ADS vs GNU ⓑ 대충의 초간단 Assembly와 Reverse Engineering ⓒ ARM, Thumb mode와 S 접미사 ⓓ ARM과 Thumb 사이의 Veneer ⓔ Inline Assembly와 INTLOCK의 구현 ⓕ Pipe li...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/bj-11723/" class="btn btn-outline-primary" aria-label="이전 글" ><p>백준 11723. 집합</p></a> <a href="/posts/ZZZ-offline/" class="btn btn-outline-primary" aria-label="다음 글" ><p>2024 젠레스 존 제로 세빛섬 런칭 오프라인 이벤트</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/jinhg0214">Dukgukim</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다." >일부 권리 보유</span></p><p>Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.2.4" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">인기 태그</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/bruteforce/">bruteforce</a> <a class="post-tag btn btn-outline-primary" href="/tags/bfs/">bfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/cpp/">cpp</a> <a class="post-tag btn btn-outline-primary" href="/tags/impl/">impl</a> <a class="post-tag btn btn-outline-primary" href="/tags/graph/">graph</a> <a class="post-tag btn btn-outline-primary" href="/tags/search/">search</a> <a class="post-tag btn btn-outline-primary" href="/tags/dfs/">dfs</a> <a class="post-tag btn btn-outline-primary" href="/tags/sort/">sort</a> <a class="post-tag btn btn-outline-primary" href="/tags/dijkstra/">dijkstra</a> <a class="post-tag btn btn-outline-primary" href="/tags/protocol/">protocol</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask" class="d-none position-fixed w-100 h-100 z-1"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></aside><script> document.addEventListener('DOMContentLoaded', () => { SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{content}</p></article>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); }); </script>
